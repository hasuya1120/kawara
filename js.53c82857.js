parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"asWa":[function(require,module,exports) {
!function(e){"use strict";function n(e,n,r){return r.a=e,r.f=n,r}function r(e){return n(2,e,function(n){return function(r){return e(n,r)}})}function o(e){return n(3,e,function(n){return function(r){return function(o){return e(n,r,o)}}})}function t(e){return n(4,e,function(n){return function(r){return function(o){return function(t){return e(n,r,o,t)}}}})}function a(e){return n(5,e,function(n){return function(r){return function(o){return function(t){return function(a){return e(n,r,o,t,a)}}}}})}function i(e){return n(6,e,function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return e(n,r,o,t,a,i)}}}}}})}function c(e){return n(7,e,function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return e(n,r,o,t,a,i,c)}}}}}}})}function l(e){return n(8,e,function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return function(l){return e(n,r,o,t,a,i,c,l)}}}}}}}})}function u(e){return n(9,e,function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return function(l){return function(u){return e(n,r,o,t,a,i,c,l,u)}}}}}}}}})}function s(e,n,r){return 2===e.a?e.f(n,r):e(n)(r)}function f(e,n,r,o){return 3===e.a?e.f(n,r,o):e(n)(r)(o)}function d(e,n,r,o,t){return 4===e.a?e.f(n,r,o,t):e(n)(r)(o)(t)}function m(e,n,r,o,t,a){return 5===e.a?e.f(n,r,o,t,a):e(n)(r)(o)(t)(a)}function v(e,n,r,o,t,a,i){return 6===e.a?e.f(n,r,o,t,a,i):e(n)(r)(o)(t)(a)(i)}function p(e,n,r,o,t,a,i,c){return 7===e.a?e.f(n,r,o,t,a,i,c):e(n)(r)(o)(t)(a)(i)(c)}function g(e,n,r,o,t,a,i,c,l){return 8===e.a?e.f(n,r,o,t,a,i,c,l):e(n)(r)(o)(t)(a)(i)(c)(l)}function b(e,n,r,o,t,a,i,c,l,u){return 9===e.a?e.f(n,r,o,t,a,i,c,l,u):e(n)(r)(o)(t)(a)(i)(c)(l)(u)}function h(e,n){for(var r,o=[],t=x(e,n,0,o);t&&(r=o.pop());t=x(r.a,r.b,0,o));return t}function x(e,n,r,o){if(e===n)return!0;if("object"!=typeof e||null===e||null===n)return"function"==typeof e&&_(5),!1;if(r>100)return o.push(C(e,n)),!0;for(var t in 0>e.$&&(e=Bn(e),n=Bn(n)),e)if(!x(e[t],n[t],r+1,o))return!1;return!0}function P(e,n,r){if("object"!=typeof e)return e===n?0:n>e?-1:1;if(void 0===e.$)return(r=P(e.a,n.a))?r:(r=P(e.b,n.b))?r:P(e.c,n.c);for(;e.b&&n.b&&!(r=P(e.a,n.a));e=e.b,n=n.b);return r||(e.b?1:n.b?-1:0)}function C(e,n){return{a:e,b:n}}function y(e,n,r){return{a:e,b:n,c:r}}var M={$:0};function T(e,n){return{$:1,a:e,b:n}}var L=r(T);function w(e){for(var n=M,r=e.length;r--;)n=T(e[r],n);return n}var N=o(function(e,n,r){for(var o=[];n.b&&r.b;n=n.b,r=r.b)o.push(s(e,n.a,r.a));return w(o)}),z=o(function(e,n,r){for(var o=[],t=0;e>t;t++)o[t]=r(n+t);return o}),S=r(function(e,n){for(var r=[],o=0;e>o&&n.b;o++)r[o]=n.a,n=n.b;return r.length=o,C(r,n)}),D=o(function(e,n,r){for(var o=r.length-1;o>=0;o--)n=s(e,r[o],n);return n});function _(e){throw Error("https://github.com/elm/core/blob/1.0.0/hints/"+e+".md")}var V=r(Math.pow),A=r(function(e,n){var r=n%e;return 0===e?_(11):r>0&&0>e||0>r&&e>0?r+e:r}),q=Math.cos,F=Math.sin,B=Math.tan,R=Math.ceil,$=Math.floor,E=Math.round,j=Math.sqrt,k=Math.log,I=r(function(e,n){return n.join(e)});function O(e){return e+""}function H(e){return{$:2,b:e}}H(function(e){return"number"!=typeof e?K("an INT",e):e>-2147483647&&2147483647>e&&(0|e)===e?On(e):!isFinite(e)||e%1?K("an INT",e):On(e)}),H(function(e){return"boolean"==typeof e?On(e):K("a BOOL",e)}),H(function(e){return"number"==typeof e?On(e):K("a FLOAT",e)}),H(function(e){return On(J(e))}),H(function(e){return"string"==typeof e?On(e):e instanceof String?On(e+""):K("a STRING",e)});var W=r(function(e,n){return U(e,ee(n))});function U(e,n){switch(e.$){case 2:return e.b(n);case 5:return null===n?On(e.c):K("null",n);case 3:return G(n)?Y(e.b,n,w):K("a LIST",n);case 4:return G(n)?Y(e.b,n,Z):K("an ARRAY",n);case 6:var r=e.d;if("object"!=typeof n||null===n||!(r in n))return K("an OBJECT with a field named `"+r+"`",n);var o=U(e.b,n[r]);return xr(o)?o:En(s(kn,r,o.a));case 7:var t=e.e;return G(n)?n.length>t?(o=U(e.b,n[t]),xr(o)?o:En(s(In,t,o.a))):K("a LONGER array. Need index "+t+" but only see "+n.length+" entries",n):K("an ARRAY",n);case 8:if("object"!=typeof n||null===n||G(n))return K("an OBJECT",n);var a=M;for(var i in n)if(n.hasOwnProperty(i)){if(o=U(e.b,n[i]),!xr(o))return En(s(kn,i,o.a));a=T(C(i,o.a),a)}return On(nr(a));case 9:for(var c=e.f,l=e.g,u=0;l.length>u;u++){if(o=U(l[u],n),!xr(o))return o;c=c(o.a)}return On(c);case 10:return o=U(e.b,n),xr(o)?U(e.h(o.a),n):o;case 11:for(var f=M,d=e.g;d.b;d=d.b){if(o=U(d.a,n),xr(o))return o;f=T(o.a,f)}return En(Hn(nr(f)));case 1:return En(s(jn,e.a,J(n)));case 0:return On(e.a)}}function Y(e,n,r){for(var o=n.length,t=[],a=0;o>a;a++){var i=U(e,n[a]);if(!xr(i))return En(s(In,a,i.a));t[a]=i.a}return On(r(t))}function G(e){return Array.isArray(e)||"undefined"!=typeof FileList&&e instanceof FileList}function Z(e){return s(hr,e.length,function(n){return e[n]})}function K(e,n){return En(s(jn,"Expecting "+e,J(n)))}function X(e,n){if(e===n)return!0;if(e.$!==n.$)return!1;switch(e.$){case 0:case 1:return e.a===n.a;case 2:return e.b===n.b;case 5:return e.c===n.c;case 3:case 4:case 8:return X(e.b,n.b);case 6:return e.d===n.d&&X(e.b,n.b);case 7:return e.e===n.e&&X(e.b,n.b);case 9:return e.f===n.f&&Q(e.g,n.g);case 10:return e.h===n.h&&X(e.b,n.b);case 11:return Q(e.g,n.g)}}function Q(e,n){var r=e.length;if(r!==n.length)return!1;for(var o=0;r>o;o++)if(!X(e[o],n[o]))return!1;return!0}function J(e){return e}function ee(e){return e}function ne(e){return{$:0,a:e}}function re(e){return{$:2,b:e,c:null}}J(null);var oe=r(function(e,n){return{$:3,b:e,d:n}}),te=0;function ae(e){var n={$:0,e:te++,f:e,g:null,h:[]};return le(n),n}var ie=!1,ce=[];function le(e){if(ce.push(e),!ie){for(ie=!0;e=ce.shift();)ue(e);ie=!1}}function ue(e){for(;e.f;){var n=e.f.$;if(0===n||1===n){for(;e.g&&e.g.$!==n;)e.g=e.g.i;if(!e.g)return;e.f=e.g.b(e.f.a),e.g=e.g.i}else{if(2===n)return void(e.f.c=e.f.b(function(n){e.f=n,le(e)}));if(5===n){if(0===e.h.length)return;e.f=e.f.b(e.h.shift())}else e.g={$:3===n?0:1,b:e.f.b,i:e.g},e.f=e.f.d}}}var se={};function fe(e,n){var r={g:n,h:void 0},o=e.c,t=e.d,a=e.e,i=e.f;function c(e){return s(oe,c,{$:5,b:function(n){var c=n.a;return 0===n.$?f(t,r,c,e):a&&i?d(o,r,c.i,c.j,e):f(o,r,a?c.i:c.j,e)}})}return r.h=ae(s(oe,c,e.b))}var de=r(function(e,n){return re(function(r){e.g(n),r(ne(0))})});function me(e){return{$:2,m:e}}var ve,pe=[],ge=!1;function be(e,n,r){if(pe.push({p:e,q:n,r:r}),!ge){ge=!0;for(var o;o=pe.shift();)he(o.p,o.q,o.r);ge=!1}}function he(e,n,r){var o,t={};for(var a in xe(!0,n,t,null),xe(!1,r,t,null),e)(o=e[a]).h.push({$:"fx",a:t[a]||{i:M,j:M}}),le(o)}function xe(e,n,r,o){switch(n.$){case 1:var t=n.k,a=function(e,r,o){function t(e){for(var n=o;n;n=n.t)e=n.s(e);return e}return s(e?se[r].e:se[r].f,t,n.l)}(e,t,o);return void(r[t]=function(e,n,r){return r=r||{i:M,j:M},e?r.i=T(n,r.i):r.j=T(n,r.j),r}(e,a,r[t]));case 2:for(var i=n.m;i.b;i=i.b)xe(e,i.a,r,o);return;case 3:return void xe(e,n.o,r,{s:n.n,t:o})}}var Pe="undefined"!=typeof document?document:{};function Ce(e,n){e.appendChild(n)}function ye(e){return{$:0,a:e}}var Me,Te=r(function(e,n){return r(function(r,o){for(var t=[],a=0;o.b;o=o.b){var i=o.a;a+=i.b||0,t.push(i)}return a+=t.length,{$:1,c:n,d:ze(r),e:t,f:e,b:a}})})(void 0),Le=r(function(e,n){return r(function(r,o){for(var t=[],a=0;o.b;o=o.b){var i=o.a;a+=i.b.b||0,t.push(i)}return a+=t.length,{$:2,c:n,d:ze(r),e:t,f:e,b:a}})})(void 0),we=r(function(e,n){return{$:"a1",n:e,o:n}}),Ne=r(function(e,n){return{$:"a3",n:e,o:n}});function ze(e){for(var n={};e.b;e=e.b){var r=e.a,o=r.$,t=r.n,a=r.o;if("a2"!==o){var i=n[o]||(n[o]={});"a3"===o&&"class"===t?Se(i,t,a):i[t]=a}else"className"===t?Se(n,t,ee(a)):n[t]=ee(a)}return n}function Se(e,n,r){var o=e[n];e[n]=o?o+" "+r:r}function De(e,n){var r=e.$;if(5===r)return De(e.k||(e.k=e.m()),n);if(0===r)return Pe.createTextNode(e.a);if(4===r){for(var o=e.k,t=e.j;4===o.$;)"object"!=typeof t?t=[t,o.j]:t.push(o.j),o=o.k;var a={j:t,p:n};return(i=De(o,a)).elm_event_node_ref=a,i}if(3===r)return _e(i=e.h(e.g),n,e.d),i;var i=e.f?Pe.createElementNS(e.f,e.c):Pe.createElement(e.c);ve&&"a"==e.c&&i.addEventListener("click",ve(i)),_e(i,n,e.d);for(var c=e.e,l=0;c.length>l;l++)Ce(i,De(1===r?c[l]:c[l].b,n));return i}function _e(e,n,r){for(var o in r){var t=r[o];"a1"===o?Ve(e,t):"a0"===o?Fe(e,n,t):"a3"===o?Ae(e,t):"a4"===o?qe(e,t):("value"!==o&&"checked"!==o||e[o]!==t)&&(e[o]=t)}}function Ve(e,n){var r=e.style;for(var o in n)r[o]=n[o]}function Ae(e,n){for(var r in n){var o=n[r];void 0!==o?e.setAttribute(r,o):e.removeAttribute(r)}}function qe(e,n){for(var r in n){var o=n[r],t=o.f,a=o.o;void 0!==a?e.setAttributeNS(t,r,a):e.removeAttributeNS(t,r)}}function Fe(e,n,r){var o=e.elmFs||(e.elmFs={});for(var t in r){var a=r[t],i=o[t];if(a){if(i){if(i.q.$===a.$){i.q=a;continue}e.removeEventListener(t,i)}i=Be(n,a),e.addEventListener(t,i,Me&&{passive:2>Pr(a)}),o[t]=i}else e.removeEventListener(t,i),o[t]=void 0}}try{window.addEventListener("t",null,Object.defineProperty({},"passive",{get:function(){Me=!0}}))}catch(e){}function Be(e,n){function r(n){var o=r.q,t=U(o.a,n);if(xr(t)){for(var a,i=Pr(o),c=t.a,l=i?3>i?c.a:c.at:c,u=1==i?c.b:3==i&&c.cR,s=(u&&n.stopPropagation(),(2==i?c.b:3==i&&c.cI)&&n.preventDefault(),e);a=s.j;){if("function"==typeof a)l=a(l);else for(var f=a.length;f--;)l=a[f](l);s=s.p}s(l,u)}}return r.q=n,r}function Re(e,n){return e.$==n.$&&X(e.a,n.a)}function $e(e,n,r,o){var t={$:n,r:r,s:o,t:void 0,u:void 0};return e.push(t),t}function Ee(e,n,r,o){if(e!==n){var t=e.$,a=n.$;if(t!==a){if(1!==t||2!==a)return void $e(r,0,o,n);n=function(e){for(var n=e.e,r=n.length,o=[],t=0;r>t;t++)o[t]=n[t].b;return{$:1,c:e.c,d:e.d,e:o,f:e.f,b:e.b}}(n),a=1}switch(a){case 5:for(var i=e.l,c=n.l,l=i.length,u=l===c.length;u&&l--;)u=i[l]===c[l];if(u)return void(n.k=e.k);n.k=n.m();var s=[];return Ee(e.k,n.k,s,0),void(s.length>0&&$e(r,1,o,s));case 4:for(var f=e.j,d=n.j,m=!1,v=e.k;4===v.$;)m=!0,"object"!=typeof f?f=[f,v.j]:f.push(v.j),v=v.k;for(var p=n.k;4===p.$;)m=!0,"object"!=typeof d?d=[d,p.j]:d.push(p.j),p=p.k;return m&&f.length!==d.length?void $e(r,0,o,n):((m?function(e,n){for(var r=0;e.length>r;r++)if(e[r]!==n[r])return!1;return!0}(f,d):f===d)||$e(r,2,o,d),void Ee(v,p,r,o+1));case 0:return void(e.a!==n.a&&$e(r,3,o,n.a));case 1:return void je(e,n,r,o,Ie);case 2:return void je(e,n,r,o,Oe);case 3:if(e.h!==n.h)return void $e(r,0,o,n);var g=ke(e.d,n.d);g&&$e(r,4,o,g);var b=n.i(e.g,n.g);return void(b&&$e(r,5,o,b))}}}function je(e,n,r,o,t){if(e.c===n.c&&e.f===n.f){var a=ke(e.d,n.d);a&&$e(r,4,o,a),t(e,n,r,o)}else $e(r,0,o,n)}function ke(e,n,r){var o;for(var t in e)if("a1"!==t&&"a0"!==t&&"a3"!==t&&"a4"!==t)if(t in n){var a=e[t],i=n[t];a===i&&"value"!==t&&"checked"!==t||"a0"===r&&Re(a,i)||((o=o||{})[t]=i)}else(o=o||{})[t]=r?"a1"===r?"":"a0"===r||"a3"===r?void 0:{f:e[t].f,o:void 0}:"string"==typeof e[t]?"":null;else{var c=ke(e[t],n[t]||{},t);c&&((o=o||{})[t]=c)}for(var l in n)l in e||((o=o||{})[l]=n[l]);return o}function Ie(e,n,r,o){var t=e.e,a=n.e,i=t.length,c=a.length;i>c?$e(r,6,o,{v:c,i:i-c}):c>i&&$e(r,7,o,{v:i,e:a});for(var l=c>i?i:c,u=0;l>u;u++){var s=t[u];Ee(s,a[u],r,++o),o+=s.b||0}}function Oe(e,n,r,o){for(var t=[],a={},i=[],c=e.e,l=n.e,u=c.length,s=l.length,f=0,d=0,m=o;u>f&&s>d;){var v=(w=c[f]).a,p=(N=l[d]).a,g=w.b,b=N.b,h=void 0,x=void 0;if(v!==p){var P=c[f+1],C=l[d+1];if(P){var y=P.a,M=P.b;x=p===y}if(C){var T=C.a,L=C.b;h=v===T}if(h&&x)Ee(g,L,t,++m),We(a,t,v,b,d,i),m+=g.b||0,Ue(a,t,v,M,++m),m+=M.b||0,f+=2,d+=2;else if(h)m++,We(a,t,p,b,d,i),Ee(g,L,t,m),m+=g.b||0,f+=1,d+=2;else if(x)Ue(a,t,v,g,++m),m+=g.b||0,Ee(M,b,t,++m),m+=M.b||0,f+=2,d+=1;else{if(!P||y!==T)break;Ue(a,t,v,g,++m),We(a,t,p,b,d,i),m+=g.b||0,Ee(M,L,t,++m),m+=M.b||0,f+=2,d+=2}}else Ee(g,b,t,++m),m+=g.b||0,f++,d++}for(;u>f;){var w;Ue(a,t,(w=c[f]).a,g=w.b,++m),m+=g.b||0,f++}for(;s>d;){var N,z=z||[];We(a,t,(N=l[d]).a,N.b,void 0,z),d++}(t.length>0||i.length>0||z)&&$e(r,8,o,{w:t,x:i,y:z})}var He="_elmW6BL";function We(e,n,r,o,t,a){var i=e[r];if(!i)return a.push({r:t,A:i={c:0,z:o,r:t,s:void 0}}),void(e[r]=i);if(1===i.c){a.push({r:t,A:i}),i.c=2;var c=[];return Ee(i.z,o,c,i.r),i.r=t,void(i.s.s={w:c,A:i})}We(e,n,r+He,o,t,a)}function Ue(e,n,r,o,t){var a=e[r];if(a){if(0===a.c){a.c=2;var i=[];return Ee(o,a.z,i,t),void $e(n,9,t,{w:i,A:a})}Ue(e,n,r+He,o,t)}else{var c=$e(n,9,t,void 0);e[r]={c:1,z:o,r:t,s:c}}}function Ye(e,n,r,o){return 0===r.length?e:(function e(n,r,o,t){!function n(r,o,t,a,i,c,l){for(var u=t[a],s=u.r;s===i;){var f=u.$;if(1===f)e(r,o.k,u.s,l);else if(8===f)u.t=r,u.u=l,(d=u.s.w).length>0&&n(r,o,d,0,i,c,l);else if(9===f){u.t=r,u.u=l;var d,m=u.s;m&&(m.A.s=r,(d=m.w).length>0&&n(r,o,d,0,i,c,l))}else u.t=r,u.u=l;if(!(u=t[++a])||(s=u.r)>c)return a}var v=o.$;if(4===v){for(var p=o.k;4===p.$;)p=p.k;return n(r,p,t,a,i+1,c,r.elm_event_node_ref)}for(var g=o.e,b=r.childNodes,h=0;g.length>h;h++){var x=1===v?g[h]:g[h].b,P=++i+(x.b||0);if(!(i>s||s>P||(u=t[a=n(b[h],x,t,a,i,P,l)])&&(s=u.r)<=c))return a;i=P}return a}(n,r,o,0,0,r.b,t)}(e,n,r,o),Ge(e,r))}function Ge(e,n){for(var r=0;n.length>r;r++){var o=n[r],t=o.t,a=Ze(t,o);t===e&&(e=a)}return e}function Ze(e,n){switch(n.$){case 0:return function(e){var r=e.parentNode,o=De(n.s,n.u);return o.elm_event_node_ref||(o.elm_event_node_ref=e.elm_event_node_ref),r&&o!==e&&r.replaceChild(o,e),o}(e);case 4:return _e(e,n.u,n.s),e;case 3:return e.replaceData(0,e.length,n.s),e;case 1:return Ge(e,n.s);case 2:return e.elm_event_node_ref?e.elm_event_node_ref.j=n.s:e.elm_event_node_ref={j:n.s,p:n.u},e;case 6:for(var r=n.s,o=0;r.i>o;o++)e.removeChild(e.childNodes[r.v]);return e;case 7:for(var t=(r=n.s).e,a=e.childNodes[o=r.v];t.length>o;o++)e.insertBefore(De(t[o],n.u),a);return e;case 9:if(!(r=n.s))return e.parentNode.removeChild(e),e;var i=r.A;return void 0!==i.r&&e.parentNode.removeChild(e),i.s=Ge(e,r.w),e;case 8:return function(e,n){var r=n.s,o=function(e,n){if(e){for(var r=Pe.createDocumentFragment(),o=0;e.length>o;o++){var t=e[o].A;Ce(r,2===t.c?t.s:De(t.z,n.u))}return r}}(r.y,n);e=Ge(e,r.w);for(var t=r.x,a=0;t.length>a;a++){var i=t[a],c=i.A,l=2===c.c?c.s:De(c.z,n.u);e.insertBefore(l,e.childNodes[i.r])}return o&&Ce(e,o),e}(e,n);case 5:return n.s(e);default:_(10)}}var Ke=t(function(e,n,r,o){return function(e,n,r,o,t,a){var i=s(W,e,J(n?n.flags:void 0));xr(i)||_(2);var c={},l=r(i.a),u=l.a,f=a(m,u),d=function(e,n){var r;for(var o in se){var t=se[o];t.a&&((r=r||{})[o]=t.a(o,n)),e[o]=fe(t,n)}return r}(c,m);function m(e,n){var r=s(o,e,u);f(u=r.a,n),be(c,r.b,t(u))}return be(c,l.b,t(u)),d?{ports:d}:{}}(n,o,e.e1,e.fz,e.fu,function(n,r){var t=e.fC,a=o.node,i=function e(n){if(3===n.nodeType)return ye(n.textContent);if(1!==n.nodeType)return ye("");for(var r=M,o=n.attributes,t=o.length;t--;){var a=o[t];r=T(s(Ne,a.name,a.value),r)}var i=n.tagName.toLowerCase(),c=M,l=n.childNodes;for(t=l.length;t--;)c=T(e(l[t]),c);return f(Te,i,r,c)}(a);return function(e,n){n(e);var r=0;function o(){r=1===r?0:(Xe(o),n(e),1)}return function(t,a){e=t,a?(n(e),2===r&&(r=1)):(0===r&&Xe(o),r=2)}}(r,function(e){var r=t(e),o=function(e,n){var r=[];return Ee(e,n,r,0),r}(i,r);a=Ye(a,i,o,n),i=r})})}),Xe=("undefined"!=typeof cancelAnimationFrame&&cancelAnimationFrame,"undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){return setTimeout(e,1e3/60)});"undefined"!=typeof document&&document,"undefined"!=typeof window&&window;var Qe=r(function(e,n){return new Float64Array([e,n])});new Float64Array(3),new Float64Array(3),new Float64Array(3);var Je=o(function(e,n,r){return new Float64Array([e,n,r])}),en=r(function(e,n){return new Float64Array([n[0]*e,n[1]*e,n[2]*e])}),nn=t(function(e,n,r,o){return new Float64Array([e,n,r,o])});new Float64Array(16),new Float64Array(16),new Float64Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);var rn=0;function on(e,n){for(;n.b;n=n.b)e(n.a)}function tn(e){for(var n=0;e.b;e=e.b)n++;return n}var an="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){setTimeout(e,1e3/60)},cn=a(function(e,n,r,o,t){return{$:0,a:e,b:n,c:r,d:o,e:t}}),ln=r(function(e,n){var r=e.blend;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.BLEND),r.enabled=!0),r.a===n.a&&r.d===n.d||(e.gl.blendEquationSeparate(n.a,n.d),r.a=n.a,r.d=n.d),r.b===n.b&&r.c===n.c&&r.e===n.e&&r.f===n.f||(e.gl.blendFuncSeparate(n.b,n.c,n.e,n.f),r.b=n.b,r.c=n.c,r.e=n.e,r.f=n.f),r.g===n.g&&r.h===n.h&&r.i===n.i&&r.j===n.j||(e.gl.blendColor(n.g,n.h,n.i,n.j),r.g=n.g,r.h=n.h,r.i=n.i,r.j=n.j)}),un=r(function(e,n){var r=e.depthTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.DEPTH_TEST),r.enabled=!0),r.a!==n.a&&(e.gl.depthFunc(n.a),r.a=n.a),r.b!==n.b&&(e.gl.depthMask(n.b),r.b=n.b),r.c===n.c&&r.d===n.d||(e.gl.depthRange(n.c,n.d),r.c=n.c,r.d=n.d)}),sn=r(function(e,n){var r=e.stencilTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.STENCIL_TEST),r.enabled=!0),r.d===n.d&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.FRONT,n.d,n.a,n.b),r.d=n.d),r.e===n.e&&r.f===n.f&&r.g===n.g||(e.gl.stencilOpSeparate(e.gl.FRONT,n.e,n.f,n.g),r.e=n.e,r.f=n.f,r.g=n.g),r.c!==n.c&&(e.gl.stencilMask(n.c),r.c=n.c),r.h===n.h&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.BACK,n.h,n.a,n.b),r.h=n.h,r.a=n.a,r.b=n.b),r.i===n.i&&r.j===n.j&&r.k===n.k||(e.gl.stencilOpSeparate(e.gl.BACK,n.i,n.j,n.k),r.i=n.i,r.j=n.j,r.k=n.k)}),fn=r(function(e,n){var r=e.scissor;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SCISSOR_TEST),r.enabled=!0),r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.scissor(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),dn=r(function(e,n){var r=e.colorMask;r.toggle=e.toggle,r.enabled=!0,r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.colorMask(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),mn=r(function(e,n){var r=e.cullFace;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.CULL_FACE),r.enabled=!0),r.a!==n.a&&(e.gl.cullFace(n.a),r.a=n.a)}),vn=r(function(e,n){var r=e.polygonOffset;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.POLYGON_OFFSET_FILL),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.polygonOffset(n.a,n.b),r.a=n.a,r.b=n.b)}),pn=r(function(e,n){var r=e.sampleCoverage;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SAMPLE_COVERAGE),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.sampleCoverage(n.a,n.b),r.a=n.a,r.b=n.b)}),gn=function(e){e.scissor.enabled&&(e.gl.disable(e.gl.SCISSOR_TEST),e.scissor.enabled=!1)},bn=function(e){var n=e.colorMask;n.a&&n.b&&n.c&&n.d||(e.gl.colorMask(!0,!0,!0,!0),n.a=!0,n.b=!0,n.c=!0,n.d=!0)},hn=["blend","depthTest","stencilTest","scissor","colorMask","cullFace","polygonOffset","sampleCoverage","sampleAlphaToCoverage"],xn=[function(e){e.blend.enabled&&(e.gl.disable(e.gl.BLEND),e.blend.enabled=!1)},function(e){e.depthTest.enabled&&(e.gl.disable(e.gl.DEPTH_TEST),e.depthTest.enabled=!1)},function(e){e.stencilTest.enabled&&(e.gl.disable(e.gl.STENCIL_TEST),e.stencilTest.enabled=!1)},gn,bn,function(e){e.gl.disable(e.gl.CULL_FACE)},function(e){e.gl.disable(e.gl.POLYGON_OFFSET_FILL)},function(e){e.gl.disable(e.gl.SAMPLE_COVERAGE)},function(e){e.gl.disable(e.gl.SAMPLE_ALPHA_TO_COVERAGE)}];function Pn(e,n,r){var o=e.createShader(r);return e.shaderSource(o,"#extension GL_OES_standard_derivatives : enable\n"+n),e.compileShader(o),o}function Cn(e,n){switch(n){case e.FLOAT:return{size:1,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC2:return{size:2,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC3:return{size:3,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC4:return{size:4,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_MAT4:return{size:4,arraySize:4,type:Float32Array,baseType:e.FLOAT};case e.INT:return{size:1,arraySize:1,type:Int32Array,baseType:e.INT}}}function yn(e,n,r,o){for(var t=r.a.c8,a=[],i=0;t>i;i++)a.push(String.fromCharCode(97+i));var c=Cn(e,n.type);if(void 0===c)throw Error("No info available for: "+n.type);var l=0,u=c.size*c.arraySize*t,s=new c.type(tn(r.b)*u);on(function(e){!function(e,n,r,o,i){var c;if(1===t)for(c=0;n>c;c++)e[r++]=1===n?o[i]:o[i][c];else a.forEach(function(t){for(c=0;n>c;c++)e[r++]=1===n?o[t][i]:o[t][i][c]})}(s,c.size*c.arraySize,l,e,o[n.name]||n.name),l+=u},r.b);var f=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,f),e.bufferData(e.ARRAY_BUFFER,s,e.STATIC_DRAW),f}function Mn(e,n){return e+"#"+n}var Tn=r(function(e,n){var r=e.f,o=r.gl;return o?(o.viewport(0,0,o.drawingBufferWidth,o.drawingBufferHeight),r.depthTest.b||(o.depthMask(!0),r.depthTest.b=!0),r.stencilTest.c!==r.STENCIL_WRITEMASK&&(o.stencilMask(r.STENCIL_WRITEMASK),r.stencilTest.c=r.STENCIL_WRITEMASK),gn(r),bn(r),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT|o.STENCIL_BUFFER_BIT),on(function(n){if(n.d.b.b){var t,a,i,c,l;if(n.b.id&&n.c.id&&(t=Mn(n.b.id,n.c.id),a=r.programs[t]),!a){var u,s;n.b.id?u=r.shaders[n.b.id]:n.b.id=rn++,u||(u=Pn(o,n.b.src,o.VERTEX_SHADER),r.shaders[n.b.id]=u),n.c.id?s=r.shaders[n.c.id]:n.c.id=rn++,s||(s=Pn(o,n.c.src,o.FRAGMENT_SHADER),r.shaders[n.c.id]=s);var f=function(e,n,r){var o=e.createProgram();if(e.attachShader(o,n),e.attachShader(o,r),e.linkProgram(o),!e.getProgramParameter(o,e.LINK_STATUS))throw"Link failed: "+e.getProgramInfoLog(o)+"\nvs info-log: "+e.getShaderInfoLog(n)+"\nfs info-log: "+e.getShaderInfoLog(r);return o}(o,u,s);(a={glProgram:f,attributes:Object.assign({},n.b.attributes,n.c.attributes),currentUniforms:{},activeAttributes:[],activeAttributeLocations:[]}).uniformSetters=function(e,n,r,o){var t=r.glProgram,a=r.currentUniforms,i=0,c=n.f;function l(n,r){var o=r.name,t=e.getUniformLocation(n,o);switch(r.type){case e.INT:return function(n){a[o]!==n&&(e.uniform1i(t,n),a[o]=n)};case e.FLOAT:return function(n){a[o]!==n&&(e.uniform1f(t,n),a[o]=n)};case e.FLOAT_VEC2:return function(n){a[o]!==n&&(e.uniform2f(t,n[0],n[1]),a[o]=n)};case e.FLOAT_VEC3:return function(n){a[o]!==n&&(e.uniform3f(t,n[0],n[1],n[2]),a[o]=n)};case e.FLOAT_VEC4:return function(n){a[o]!==n&&(e.uniform4f(t,n[0],n[1],n[2],n[3]),a[o]=n)};case e.FLOAT_MAT4:return function(n){a[o]!==n&&(e.uniformMatrix4fv(t,!1,new Float32Array(n)),a[o]=n)};case e.SAMPLER_2D:var l=i++;return function(n){e.activeTexture(e.TEXTURE0+l);var r=c.textures.get(n);r||(r=n.eE(e),c.textures.set(n,r)),e.bindTexture(e.TEXTURE_2D,r),a[o]!==n&&(e.uniform1i(t,l),a[o]=n)};case e.BOOL:return function(n){a[o]!==n&&(e.uniform1i(t,n),a[o]=n)};default:return function(){}}}for(var u={},s=e.getProgramParameter(t,e.ACTIVE_UNIFORMS),f=0;s>f;f++){var d=e.getActiveUniform(t,f);u[o[d.name]||d.name]=l(t,d)}return u}(o,e,a,Object.assign({},n.b.uniforms,n.c.uniforms));var d=o.getProgramParameter(f,o.ACTIVE_ATTRIBUTES);for(i=0;d>i;i++){var m=o.getActiveAttrib(f,i),v=o.getAttribLocation(f,m.name);a.activeAttributes.push(m),a.activeAttributeLocations.push(v)}t=Mn(n.b.id,n.c.id),r.programs[t]=a}r.lastProgId!==t&&(o.useProgram(a.glProgram),r.lastProgId=t),c=a.uniformSetters,Object.keys(l=n.e).forEach(function(e){var n=c[e];n&&n(l[e])});var p=r.buffers.get(n.d);for(p||(p=function(e,n){if(n.a.di>0){var r=e.createBuffer(),o=function(e,n){var r,o=new Uint16Array(tn(e)*n),t=0;return on(function(e){if(1===n)o[t++]=e;else for(r=0;n>r;r++)o[t++]=e[String.fromCharCode(97+r)]},e),o}(n.c,n.a.di);return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r),e.bufferData(e.ELEMENT_ARRAY_BUFFER,o,e.STATIC_DRAW),{numIndices:o.length,indexBuffer:r,buffers:{}}}return{numIndices:n.a.c8*tn(n.b),indexBuffer:null,buffers:{}}}(o,n.d),r.buffers.set(n.d,p)),i=0;a.activeAttributes.length>i;i++){v=a.activeAttributeLocations[i],void 0===p.buffers[(m=a.activeAttributes[i]).name]&&(p.buffers[m.name]=yn(o,m,n.d,a.attributes)),o.bindBuffer(o.ARRAY_BUFFER,p.buffers[m.name]);var g=Cn(o,m.type);if(1===g.arraySize)o.enableVertexAttribArray(v),o.vertexAttribPointer(v,g.size,g.baseType,!1,0,0);else for(var b=4*g.size,h=b*g.arraySize,x=0;g.arraySize>x;x++)o.enableVertexAttribArray(v+x),o.vertexAttribPointer(v+x,g.size,g.baseType,!1,h,b*x)}for(r.toggle=!r.toggle,on(Ko(r),n.a),i=0;9>i;i++){var P=r[hn[i]];P.toggle!==r.toggle&&P.enabled&&(xn[i](r),P.enabled=!1,P.toggle=r.toggle)}p.indexBuffer?(o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,p.indexBuffer),o.drawElements(n.d.a.dR,p.numIndices,o.UNSIGNED_SHORT,0)):o.drawArrays(n.d.a.dR,0,p.numIndices)}},e.g),n):n}),Ln=o(function(e,n,r){return function(e,n,r,o){return{$:3,d:ze(e),g:n,h:r,i:o}}(n,{g:r,f:{},h:e},Vn,An)}),wn=r(function(e,n){e.contextAttributes.alpha=!0,e.contextAttributes.premultipliedAlpha=n.a}),Nn=r(function(e,n){e.contextAttributes.depth=!0,e.sceneSettings.push(function(e){e.clearDepth(n.a)})}),zn=r(function(e,n){e.contextAttributes.stencil=!0,e.sceneSettings.push(function(e){e.clearStencil(n.a)})}),Sn=r(function(e){e.contextAttributes.antialias=!0}),Dn=r(function(e,n){e.sceneSettings.push(function(e){e.clearColor(n.a,n.b,n.c,n.d)})}),_n=r(function(e){e.contextAttributes.preserveDrawingBuffer=!0});function Vn(e){var n={contextAttributes:{alpha:!1,depth:!1,stencil:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1},sceneSettings:[]};on(function(e){return s(Zo,n,e)},e.h);var r=Pe.createElement("canvas"),o=r.getContext&&(r.getContext("webgl",n.contextAttributes)||r.getContext("experimental-webgl",n.contextAttributes));return o&&"undefined"!=typeof WeakMap?(n.sceneSettings.forEach(function(e){e(o)}),o.getExtension("OES_standard_derivatives"),e.f.gl=o,e.f.toggle=!1,e.f.blend={enabled:!1,toggle:!1},e.f.depthTest={enabled:!1,toggle:!1},e.f.stencilTest={enabled:!1,toggle:!1},e.f.scissor={enabled:!1,toggle:!1},e.f.colorMask={enabled:!1,toggle:!1},e.f.cullFace={enabled:!1,toggle:!1},e.f.polygonOffset={enabled:!1,toggle:!1},e.f.sampleCoverage={enabled:!1,toggle:!1},e.f.sampleAlphaToCoverage={enabled:!1,toggle:!1},e.f.shaders=[],e.f.programs={},e.f.lastProgId=null,e.f.buffers=new WeakMap,e.f.textures=new WeakMap,e.f.STENCIL_WRITEMASK=o.getParameter(o.STENCIL_WRITEMASK),an(function(){return s(Tn,e,r)})):(r=Pe.createElement("div")).innerHTML='<a href="https://get.webgl.org/">Enable WebGL</a> to see this content!',r}function An(e,n){return n.f=e.f,Tn(n)}var qn=L,Fn=o(function(e,n,r){for(;;){if(-2===r.$)return n;var o=r.d,t=e,a=f(e,r.b,r.c,f(Fn,e,n,r.e));e=t,n=a,r=o}}),Bn=function(e){return f(Fn,o(function(e,n,r){return s(qn,C(e,n),r)}),M,e)},Rn=D,$n=o(function(e,n,o){var t=o.c,a=o.d,i=r(function(n,r){return f(Rn,n.$?e:i,r,n.a)});return f(Rn,i,f(Rn,e,n,a),t)}),En=function(e){return{$:1,a:e}},jn=r(function(e,n){return{$:3,a:e,b:n}}),kn=r(function(e,n){return{$:0,a:e,b:n}}),In=r(function(e,n){return{$:1,a:e,b:n}}),On=function(e){return{$:0,a:e}},Hn=function(e){return{$:2,a:e}},Wn=function(e){return{$:0,a:e}},Un={$:1},Yn=O,Gn=r(function(e,n){return s(I,e,function(e){for(var n=[];e.b;e=e.b)n.push(e.a);return n}(n))}),Zn=o(function(e,n,r){for(;;){if(!r.b)return n;var o=r.b,t=e,a=s(e,r.a,n);e=t,n=a,r=o}}),Kn=function(e){return f(Zn,r(function(e,n){return n+1}),0,e)},Xn=N,Qn=o(function(e,n,r){for(;;){if(P(e,n)>=1)return r;var o=e,t=n-1,a=s(qn,n,r);e=o,n=t,r=a}}),Jn=r(function(e,n){return f(Qn,e,n,M)}),er=r(function(e,n){return f(Xn,e,s(Jn,0,Kn(n)-1),n)}),nr=function(e){return f(Zn,qn,M,e)},rr=t(function(e,n,r,o){return{$:0,a:e,b:n,c:r,d:o}}),or=[],tr=R,ar=r(function(e,n){return k(n)/k(e)}),ir=tr(s(ar,2,32)),cr=d(rr,0,ir,or,or),lr=z,ur=function(e){return{$:1,a:e}},sr=$,fr=function(e){return e.length},dr=r(function(e,n){return P(e,n)>0?e:n}),mr=S,vr=r(function(e,n){for(;;){var r=s(mr,32,e),o=r.b,t=s(qn,{$:0,a:r.a},n);if(!o.b)return nr(t);e=o,n=t}}),pr=r(function(e,n){for(;;){var r=tr(n/32);if(1===r)return s(mr,32,e).a;e=s(vr,e,M),n=r}}),gr=r(function(e,n){if(n.n){var r=32*n.n,o=sr(s(ar,32,r-1)),t=e?nr(n.B):n.B,a=s(pr,t,n.n);return d(rr,fr(n.r)+r,s(dr,5,o*ir),a,n.r)}return d(rr,fr(n.r),ir,or,n.r)}),br=a(function(e,n,r,o,t){for(;;){if(0>n)return s(gr,!1,{B:o,n:r/32|0,r:t});var a=ur(f(lr,32,n,e));e=e,n-=32,r=r,o=s(qn,a,o),t=t}}),hr=r(function(e,n){if(e>0){var r=e%32;return m(br,n,e-r-32,e,M,f(lr,r,e-r,n))}return cr}),xr=function(e){return!e.$},Pr=function(e){switch(e.$){case 0:return 0;case 1:return 1;case 2:return 2;default:return 3}},Cr=ne,yr=Cr(0),Mr=t(function(e,n,r,o){if(o.b){var t=o.a,a=o.b;if(a.b){var i=a.a,c=a.b;if(c.b){var l=c.a,u=c.b;if(u.b){var m=u.b;return s(e,t,s(e,i,s(e,l,s(e,u.a,r>500?f(Zn,e,n,nr(m)):d(Mr,e,n,r+1,m)))))}return s(e,t,s(e,i,s(e,l,n)))}return s(e,t,s(e,i,n))}return s(e,t,n)}return n}),Tr=o(function(e,n,r){return d(Mr,e,n,0,r)}),Lr=r(function(e,n){return f(Tr,r(function(n,r){return s(qn,e(n),r)}),M,n)}),wr=oe,Nr=r(function(e,n){return s(wr,function(n){return Cr(e(n))},n)}),zr=o(function(e,n,r){return s(wr,function(n){return s(wr,function(r){return Cr(s(e,n,r))},r)},n)}),Sr=de,Dr=r(function(e,n){var r=n;return function(e){return re(function(n){n(ne(ae(e)))})}(s(wr,Sr(e),r))});se.Task={b:yr,c:o(function(e,n){return s(Nr,function(){return 0},(r=s(Lr,Dr(e),n),f(Tr,zr(qn),Cr(M),r)));var r}),d:o(function(){return Cr(0)}),e:r(function(e,n){return s(Nr,e,n)}),f:void 0};var _r,Vr,Ar,qr,Fr,Br,Rr,$r,Er,jr,kr,Ir,Or,Hr,Wr,Ur,Yr,Gr,Zr,Kr=Ke,Xr=me,Qr=Xr(M),Jr=C({},Qr),eo=me,no=eo(M),ro=r(function(){return C({},Qr)}),oo=Te("div"),to=function(e){return e},ao=function(e){return to(e/180*3.141592653589793)},io=r(function(e,n){return{en:n.eo*e.b4-n.b4*e.eo,eo:n.b4*e.en-n.en*e.b4,b4:n.en*e.eo-n.eo*e.en}}),co=function(e){return 0>e?-e:e},lo=j,uo=function(e){var n=e,r=s(dr,co(n.en),s(dr,co(n.eo),co(n.b4)));if(r){var o=n.b4/r,t=n.eo/r,a=n.en/r,i=lo(a*a+t*t+o*o);return Wn({en:a/i,eo:t/i,b4:o/i})}return Un},so=r(function(e,n){return{en:n.en-e.en,eo:n.eo-e.eo,b4:n.b4-e.b4}}),fo=r(function(e,n){return n.$?Un:e(n.a)}),mo=r(function(e,n){return n.en*e.en+n.eo*e.eo+n.b4*e.b4}),vo=r(function(e,n){return P(n,e)>0}),po=r(function(e,n){return 0>P(n,e)}),go=r(function(e,n){return n.$?Un:Wn(e(n.a))}),bo=r(function(e,n){return{en:n.en-e.en,eo:n.eo-e.eo,b4:n.b4-e.b4}}),ho=r(function(e,n){var r=n.en*e.en+n.eo*e.eo+n.b4*e.b4;return{en:e.en*r,eo:e.eo*r,b4:e.b4*r}}),xo={en:0,eo:0,b4:0},Po=o(function(e,n,r){return s(fo,function(o){return s(fo,function(t){var a,i=s(io,n,e),c=s(mo,r,i),l=s(vo,0,c)?i:s(po,0,c)?{en:-(a=i).en,eo:-a.eo,b4:-a.b4}:xo;return s(go,function(e){return y(o,t,e)},uo(l))},uo(s(bo,s(ho,o,n),n)))},uo(e))}),Co=function(e){var n=function(){var n=e,r=co(n.b4),o=co(n.eo),t=co(n.en);if(1>P(t,o)){if(1>P(t,r)){var a=lo(n.b4*n.b4+n.eo*n.eo);return{en:0,eo:-n.b4/a,b4:n.eo/a}}return a=lo(n.eo*n.eo+n.en*n.en),{en:-n.eo/a,eo:n.en/a,b4:0}}return 1>P(o,r)?(a=lo(n.b4*n.b4+n.en*n.en),{en:n.b4/a,eo:0,b4:-n.en/a}):(a=lo(n.en*n.en+n.eo*n.eo),{en:-n.eo/a,eo:n.en/a,b4:0})}();return C(n,{en:e.eo*n.b4-e.b4*n.eo,eo:e.b4*n.en-e.en*n.b4,b4:e.en*n.eo-e.eo*n.en})},yo=function(e){return e},Mo=function(e){return e},To=r(function(e,n){var r=Co(e);return Mo({cy:n,cZ:r.a,c_:r.b,c$:e})}),Lo=o(function(e,n,r){return{en:e,eo:n,b4:r}}),wo={en:0,eo:0,b4:0},No=function(e){return co(e)},zo=function(e){return.5*e},So=B,Do=function(e){return e},_o=Do({en:0,eo:0,b4:1}),Vo=(_r={fB:ao(30),fD:function(e){var n=s(so,e.eW,e.eS),r=yo(e.ej),o=f(Po,n,r,s(io,n,r));if(o.$){var t=uo(n);if(t.$){var a=Co(e.ej);return Mo({cy:e.eS,cZ:a.b,c_:e.ej,c$:a.a})}return s(To,t.a,e.eS)}var i=o.a;return Mo({cy:e.eS,cZ:i.c,c_:i.b,c$:i.a})}({eS:f(Lo,5,5,5),eW:wo,ej:_o})},Ar=zo(No(_r.fB)),qr=So(Ar),{cJ:(Vr=qr,{$:0,a:Vr}),fD:_r.fD}),Ao=function(e){return{$:0,a:e}},qo=r(function(e,n){return{$:0,a:e,b:n}}),Fo=function(e){return{aM:e.d,b8:e.c,cd:e.b,cK:e.a}},Bo=Je,Ro=t(function(e,n,r,o){return{$:0,a:e,b:n,c:r,d:o}}),$o=d(Ro,211/255,215/255,207/255,1),Eo={$:0},jo=Eo,ko=function(e){return{$:4,a:e}},Io=r(function(e,n){for(;;){if(!e.b)return n;var r=e.a;e=e.b,n=s(qn,r,n)}}),Oo=function(e){return ko(s(Io,e,M))},Ho=r(function(e,n){return{$:1,a:e,b:n}}),Wo={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        void main () {\n            gl_FragColor = texture2D(colorTexture, interpolatedUv);\n        }\n    ",attributes:{},uniforms:{colorTexture:"bF"}},Uo={src:"\n        precision lowp float;\n        \n        uniform lowp vec3 constantColor;\n        \n        void main () {\n            gl_FragColor = vec4(constantColor, 1.0);\n        }\n    ",attributes:{},uniforms:{constantColor:"aE"}},Yo={src:"\n        precision mediump float;\n        \n        uniform mediump vec3 emissiveColor;\n        uniform highp mat4 sceneProperties;\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{emissiveColor:"aP",sceneProperties:"e"}},Go={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        uniform mediump float backlight;\n        uniform highp mat4 sceneProperties;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            vec3 emissiveColor = fromSrgb(texture2D(colorTexture, interpolatedUv).rgb) * backlight;\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{backlight:"b5",colorTexture:"bF",sceneProperties:"e"}},Zo=r(function(e,n){switch(n.$){case 0:return s(wn,e,n);case 1:return s(Nn,e,n);case 2:return s(zn,e,n);case 3:return s(Sn,e,n);case 4:return s(Dn,e,n);default:return s(_n,e,n)}}),Ko=r(function(e,n){switch(n.$){case 0:return s(ln,e,n);case 1:return s(un,e,n);case 2:return s(sn,e,n);case 3:return s(fn,e,n);case 4:return s(dn,e,n);case 5:return s(mn,e,n);case 6:return s(vn,e,n);case 7:return s(pn,e,n);default:return function(e){var n=e.sampleAlphaToCoverage;n.toggle=e.toggle,n.enabled||(e.gl.enable(e.gl.SAMPLE_ALPHA_TO_COVERAGE),n.enabled=!0)}(e)}}),Xo=cn,Qo=r(function(e,n){return 0>P(e,n)?e:n}),Jo=c(function(e,n,r,o,t,a,i){for(;;){if(!i.b)return{dK:n,dL:o,dM:a,dN:e,dO:r,dP:t};var c=i.a,l=i.b,u=c.en,f=c.eo,d=c.b4;e=s(Qo,u,e),n=s(dr,u,n),r=s(Qo,f,r),o=s(dr,f,o),t=s(Qo,d,t),a=s(dr,d,a),i=l}}),et=r(function(e,n){var r=e.en,o=e.eo,t=e.b4;return p(Jo,r,r,o,o,t,t,n)}),nt=function(e){return e},rt={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 materialColor;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"U",lights12:"be",lights34:"bN",lights56:"bO",lights78:"bP",materialColor:"cp",sceneProperties:"e",viewMatrix:"f"}},ot={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D materialColorTexture;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n            vec3 materialColor = fromSrgb(texture2D(materialColorTexture, interpolatedUv).rgb);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"U",lights12:"be",lights34:"bN",lights56:"bO",lights78:"bP",materialColorTexture:"cq",normalMapTexture:"aW",sceneProperties:"e",useNormalMap:"a$",viewMatrix:"f"}},tt=function(e){return{$:5,a:e}},at=tt(1029),it=tt(1028),ct=o(function(e,n,r){return 1===n?s(qn,e?at:it,r):r}),lt={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 baseColor;\n        uniform lowp float roughness;\n        uniform lowp float metallic;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColor:"ev",enabledLights:"U",lights12:"be",lights34:"bN",lights56:"bO",lights78:"bP",metallic:"cs",roughness:"fp",sceneProperties:"e",viewMatrix:"f"}},ut={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D baseColorTexture;\n        uniform lowp vec4 constantBaseColor;\n        uniform mediump sampler2D roughnessTexture;\n        uniform lowp vec2 constantRoughness;\n        uniform mediump sampler2D metallicTexture;\n        uniform lowp vec2 constantMetallic;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getFloatValue(sampler2D texture, vec2 uv, vec2 constantValue) {\n            if (constantValue.y == 1.0) {\n                return constantValue.x;\n            } else {\n                vec4 textureColor = texture2D(texture, uv);\n                return dot(textureColor, vec4(0.2126, 0.7152, 0.0722, 0.0));\n            }\n        }\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 baseColor = fromSrgb(texture2D(baseColorTexture, interpolatedUv).rgb) * (1.0 - constantBaseColor.w) + constantBaseColor.rgb * constantBaseColor.w;\n            float roughness = getFloatValue(roughnessTexture, interpolatedUv, constantRoughness);\n            float metallic = getFloatValue(metallicTexture, interpolatedUv, constantMetallic);\n        \n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColorTexture:"b7",constantBaseColor:"b9",constantMetallic:"ca",constantRoughness:"cb",enabledLights:"U",lights12:"be",lights34:"bN",lights56:"bO",lights78:"bP",metallicTexture:"ct",normalMapTexture:"aW",roughnessTexture:"cO",sceneProperties:"e",useNormalMap:"a$",viewMatrix:"f"}},st={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n        }\n    ",attributes:{quadVertex:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",quadVertexPositions:"ai",sceneProperties:"e",viewMatrix:"f"}},ft=function(e){var n=new Float64Array(16);return n[0]=e.dt,n[1]=e.dx,n[2]=e.dB,n[3]=e.dF,n[4]=e.du,n[5]=e.dy,n[6]=e.dC,n[7]=e.dG,n[8]=e.dv,n[9]=e.dz,n[10]=e.dD,n[11]=e.dH,n[12]=e.dw,n[13]=e.dA,n[14]=e.dE,n[15]=e.dI,n},dt=function(e){return e},mt=t(function(e,n,r,o){var t=dt(o),a=dt(r),i=dt(n),c=dt(e);return ft({dt:c.en,du:i.en,dv:a.en,dw:t.en,dx:c.eo,dy:i.eo,dz:a.eo,dA:t.eo,dB:c.b4,dC:i.b4,dD:a.b4,dE:t.b4,dF:0,dG:0,dH:0,dI:0})}),vt=r(function(e,n){return{$:0,a:e,b:n}}),pt=vt({c8:1,di:0,dR:6}),gt=pt(w([{bZ:f(Bo,0,0,0)},{bZ:f(Bo,1,0,1)},{bZ:f(Bo,1,1,2)},{bZ:f(Bo,0,1,3)}])),bt=r(function(e,n){return{$:1,a:e,b:n}}),ht=r(function(e,n){return n.$?C(n.a.E,1):C(e,0)}),xt=function(e){return e[0]},Pt=function(e){return e[1]},Ct=function(e){return e[2]},yt=nn,Mt=d(yt,0,0,0,0),Tt=r(function(e,n){var r;return n.$?C(n.a.E,Mt):C(e,d(yt,xt(r=n.a),Pt(r),Ct(r),1))}),Lt=r(function(e,n){var r,o=C(e,n);return o.a.$?s(bt,C(r=o.a.a.E,Mt),s(ht,r,n)):o.b.$?s(bt,s(Tt,r=o.b.a.E,e),s(ht,r,n)):{$:0,a:o.a.a}}),wt=o(function(e,n,r){return{$:0,a:e,b:n,c:r}}),Nt=t(function(e,n,r,o){return{$:1,a:e,b:n,c:r,d:o}}),zt=t(function(e,n,r,o){return{$:0,a:e,b:n,c:r,d:o}}),St=Qe,Dt=s(St,0,0),_t=r(function(e,n){return n.$?C(n.a.E,Dt):C(e,s(St,n.a,1))}),Vt=t(function(e,n,r,o){var t,a=d(zt,e,n,r,o);return a.a.$?d(Nt,C(t=a.a.a.E,Mt),s(_t,t,n),s(_t,t,r),s(ht,t,o)):a.b.$?d(Nt,s(Tt,t=a.b.a.E,e),C(t,Dt),s(_t,t,r),s(ht,t,o)):a.c.$?d(Nt,s(Tt,t=a.c.a.E,e),s(_t,t,n),C(t,Dt),s(ht,t,o)):a.d.$?d(Nt,s(Tt,t=a.d.a.E,e),s(_t,t,n),s(_t,t,r),C(t,1)):f(wt,a.a.a,a.b.a,a.c.a)}),At=en,qt={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n        }\n    ",attributes:{quadVertex:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",quadVertexPositions:"ai",sceneProperties:"e",viewMatrix:"f"}},Ft={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n            interpolatedUv = quadVertex.xy;\n            interpolatedTangent = tangent;\n        }\n    ",attributes:{quadVertex:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",quadVertexPositions:"ai",sceneProperties:"e",viewMatrix:"f"}},Bt=o(function(e,n,r){return r>.5?n+(1-r)*(e-n):e+r*(n-e)}),Rt=o(function(e,n,r){return{en:e,eo:n,b4:r}}),$t=function(e){return f(Rt,f(Bt,(n=e).dN,n.dK,.5),f(Bt,e.dO,e.dL,.5),f(Bt,e.dP,e.dM,.5));var n},Et=function(e){return e.dM},jt=function(e){return e.dP},kt=r(function(e,n){return n-e}),It=function(e){return y(s(kt,e.dN,e.dK),s(kt,e.dO,e.dL),s(kt,jt(e),Et(e)))},Ot=function(e){return e},Ht=function(e){var n=It(e),r=n.a,o=n.b,t=n.c;return{eA:Ot($t(e)),eX:r/2,eY:o/2,eZ:t/2}},Wt={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedUv = quadVertex.xy;\n        }\n    ",attributes:{quadVertex:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",quadVertexPositions:"ai",sceneProperties:"e",viewMatrix:"f"}},Ut=a(function(e,n,r,o,t){var a=s(et,n,w([r,o,t])),i=Ht(a);return s(Ho,i,function(){switch(e.$){case 0:if(e.b.$){var a=e.b.a.E;return l(function(e,i,c,l,u,s,v,p){return m(Xo,f(ct,l,0,p),Wt,Wo,gt,{bF:a,b:c,c:i,d:s,ai:d(mt,n,r,o,t),e:e,f:u})})}var i=e.b.a;return l(function(e,a,c,l,u,s,v,p){return m(Xo,f(ct,l,0,p),st,Uo,gt,{aE:i,b:c,c:a,d:s,ai:d(mt,n,r,o,t),e:e,f:u})});case 1:if(e.b.$)return a=e.b.a.E,u=e.c,l(function(e,i,c,l,s,v,p,g){return m(Xo,f(ct,l,0,g),Wt,Go,gt,{b5:nt(u),bF:a,b:c,c:i,d:v,ai:d(mt,n,r,o,t),e:e,f:s})});var c=e.b.a,u=e.c;return l(function(e,a,i,l,v,p,g,b){return m(Xo,f(ct,l,0,b),st,Yo,gt,{b5:u,aP:s(At,nt(u),c),b:i,c:a,d:p,ai:d(mt,n,r,o,t),e:e,f:v})});case 2:var v=s(Lt,e.b,e.c);if(v.$){var p=v.a.a,g=v.b,b=g.a,h=g.b;return l(function(e,a,i,c,l,u,s,v){var g=s.a,x=s.b;return m(Xo,f(ct,c,0,v),Ft,ot,gt,{U:x,be:g.be,bN:g.bN,bO:g.bO,bP:g.bP,cq:p,b:i,c:a,aW:b,d:u,ai:d(mt,n,r,o,t),e:e,a$:h,f:l})})}var x=v.a;return l(function(e,a,i,c,l,u,s,v){var p=s.a,g=s.b;return m(Xo,f(ct,c,0,v),qt,rt,gt,{U:g,be:p.be,bN:p.bN,bO:p.bO,bP:p.bP,cp:x,b:i,c:a,d:u,ai:d(mt,n,r,o,t),e:e,f:l})});default:var P=d(Vt,e.b,e.c,e.d,e.e);if(P.$){var C=P.a,y=C.a,M=C.b,T=P.b,L=T.a,w=T.b,N=P.c,z=N.a,S=N.b,D=P.d;return b=D.a,h=D.b,l(function(e,a,i,c,l,u,s,v){var p=s.a,g=s.b;return m(Xo,f(ct,c,0,v),Ft,ut,gt,{b7:y,b9:M,ca:S,cb:w,U:g,be:p.be,bN:p.bN,bO:p.bO,bP:p.bP,ct:z,b:i,c:a,aW:b,d:u,ai:d(mt,n,r,o,t),cO:L,e:e,a$:h,f:l})})}var _=P.a,V=P.b,A=P.c;return l(function(e,a,i,c,l,u,s,v){var p=s.a,g=s.b;return m(Xo,f(ct,c,0,v),qt,lt,gt,{ev:_,U:g,be:p.be,bN:p.bN,bO:p.bO,bP:p.bP,cs:A,b:i,c:a,d:u,ai:d(mt,n,r,o,t),fp:V,e:e,f:l})})}}())}),Yt=function(e){return{$:2,a:e}},Gt=o(function(e,n,r){return{$:3,a:e,b:n,c:r}}),Zt=Gt({c8:1,di:3,dR:4}),Kt=(Fr=w([{aw:s(St,0,1)},{aw:s(St,1,1)},{aw:s(St,2,1)},{aw:s(St,3,1)},{aw:s(St,0,-1)},{aw:s(St,1,-1)},{aw:s(St,2,-1)},{aw:s(St,3,-1)}]),Br=w([y(0,1,2),y(0,2,3),y(4,6,5),y(4,7,6),y(4,5,1),y(1,0,4),y(5,6,2),y(2,1,5),y(6,7,3),y(3,2,6),y(7,4,0),y(0,3,7)]),s(Zt,Fr,Br)),Xt={src:"\n        precision highp float;\n        \n        attribute highp vec2 quadShadowVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 shadowLight;\n        uniform highp mat4 quadVertexPositions;\n        \n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        vec3 getDirectionToLight(vec3 surfacePosition, vec4 xyz_type, vec4 rgb_parameter) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                return xyz_type.xyz;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                return normalize(lightPosition - surfacePosition);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 shadowVertexPosition(vec3 position, vec3 normal, mat4 shadowLight, vec4 modelScale, mat4 modelMatrix, mat4 viewMatrix, mat4 projectionMatrix, mat4 sceneProperties) {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            vec3 worldNormal = getWorldNormal(normal, vec4(modelScale.xyz, 1.0), modelMatrix);\n            vec4 xyz_type = shadowLight[0];\n            vec4 rgb_parameter = shadowLight[1];\n            vec3 directionToLight = getDirectionToLight(worldPosition.xyz, xyz_type, rgb_parameter);\n            vec3 offset = vec3(0.0, 0.0, 0.0);\n            float sceneDiameter = sceneProperties[3][1];\n            if (dot(directionToLight, worldNormal) <= 0.0) {\n                offset = -sceneDiameter * directionToLight;\n            } else {\n                offset = -0.001 * sceneDiameter * directionToLight;\n            }\n            vec4 offsetPosition = worldPosition + vec4(offset, 0.0);\n            return projectionMatrix * (viewMatrix * offsetPosition);\n        }\n        \n        void main () {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadShadowVertex.x), quadVertexPositions, position, normal, tangent);\n            normal *= quadShadowVertex.y;\n            gl_Position = shadowVertexPosition(\n                position,\n                normal,\n                shadowLight,\n                modelScale,\n                modelMatrix,\n                viewMatrix,\n                projectionMatrix,\n                sceneProperties\n            );\n        }\n    ",attributes:{quadShadowVertex:"aw"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",quadVertexPositions:"ai",sceneProperties:"e",shadowLight:"b2",viewMatrix:"f"}},Qt={src:"\n        precision lowp float;\n        \n        void main () {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    ",attributes:{},uniforms:{}},Jt=function(e){return function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return function(l){return function(u){return function(s){return{$:2,a:e,b:n,c:r,d:o,e:t,f:a,g:i,h:c,i:l,j:u,k:s}}}}}}}}}}}},ea=o(function(e,n,r){return n(e(r))}),na=o(function(e,n,o){var t=e.cL,a=e.co,i=e.cY,c=r(function(e,n){return n(e)}),l=r(function(e,n){return n(e)}),u=function(e){return s(ea,c(e.bo),s(ea,l(e.a9),s(ea,l(e.bw),l(e.bx))))};return s(u,o,s(u,n,f(Jt,t,a,i)))}),ra=f(na,{co:0,cL:0,cY:15},{a9:7680,bo:519,bw:7680,bx:7683},{a9:7680,bo:519,bw:7680,bx:7682}),oa=f(na,{co:0,cL:0,cY:15},{a9:7680,bo:519,bw:7680,bx:7682},{a9:7680,bo:519,bw:7680,bx:7683}),ta=r(function(e,n){return s(qn,e?oa:ra,n)}),aa=t(function(e,n,r,o){return Yt(l(function(t,a,i,c,l,u,f,v){return m(Xo,s(ta,c,v),Xt,Qt,Kt,{b:i,c:a,d:u,ai:d(mt,e,n,r,o),e:t,b2:f,f:l})}))}),ia=c(function(e,n,r,o,t,a,i){var c=m(Ut,r,o,t,a,i),l=C(e,n);return l.a?l.b?Oo(w([c,d(aa,o,t,a,i)])):c:l.b?d(aa,o,t,a,i):jo}),ca=m(a(function(e,n,r,o,t){return p(ia,!0,!1,e,n,r,o,t)}),s(qo,0,Ao(function(e){var n=Fo(e);return f(Bo,n.cK,n.cd,n.b8)}($o))),f(Lo,-2,-1,0),f(Lo,2,-1,0),f(Lo,2,2,0),f(Lo,-2,2,0)),la=function(e){return e},ua=function(e){return e},sa=Do({en:0,eo:0,b4:-1}),fa=d(Ro,114/255,159/255,207/255,1),da=a(function(e,n,r,o,t){return{$:3,a:e,b:n,c:r,d:o,e:t}}),ma=o(function(e,n,r){return 0>P(r,e)?e:P(r,n)>0?n:r}),va=V,pa=function(e){return f(ma,0,1,e>.04045?s(va,(e+.055)/1.055,2.4):e/12.92)},ga={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute mediump vec2 uv;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedUv = uv;\n        }\n    ",attributes:{position:"bY",uv:"N"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},ba=t(function(e,n,r,o){return s(Ho,n,l(function(n,t,a,i,c,l,u,s){return m(Xo,f(ct,i,o,s),ga,Wo,r,{bF:e,b:a,c:t,d:l,e:n,f:c})}))}),ha={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n        }\n    ",attributes:{position:"bY"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},xa=t(function(e,n,r,o){return s(Ho,n,l(function(n,t,a,i,c,l,u,s){return m(Xo,f(ct,i,o,s),ha,Uo,r,{aE:e,b:a,c:t,d:l,e:n,f:c})}))}),Pa=r(function(e,n){return{$:3,a:e,b:n}}),Ca={src:"\n        precision lowp float;\n        \n        uniform lowp vec3 constantColor;\n        uniform lowp float pointRadius;\n        uniform highp mat4 sceneProperties;\n        \n        float pointAlpha(float pointRadius, vec2 pointCoord) {\n            float pointSize = 2.0 * pointRadius;\n            float x = (pointSize + 2.0) * (pointCoord.s - 0.5);\n            float y = (pointSize + 2.0) * (pointCoord.t - 0.5);\n            float r = sqrt(x * x + y * y);\n            float innerRadius = pointRadius;\n            float outerRadius = pointRadius + 1.0;\n            if (r > outerRadius) {\n                return 0.0;\n            } else if (r > innerRadius) {\n                return outerRadius - r;\n            } else {\n                return 1.0;\n            }\n        }\n        \n        void main () {\n            float supersampling = sceneProperties[3][0];\n            float alpha = pointAlpha(pointRadius * supersampling, gl_PointCoord);\n            gl_FragColor = vec4(constantColor, alpha);\n        }\n    ",attributes:{},uniforms:{constantColor:"aE",pointRadius:"bX",sceneProperties:"e"}},ya={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform lowp float pointRadius;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            float supersampling = sceneProperties[3][0];\n            gl_PointSize = 2.0 * pointRadius * supersampling + 2.0;\n        }\n    ",attributes:{position:"bY"},uniforms:{modelMatrix:"b",modelScale:"c",pointRadius:"bX",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},Ma=t(function(e,n,r,o){return s(Pa,r,l(function(r,t,a,i,c,l,u,s){return m(Xo,s,ya,Ca,o,{aE:e,b:a,c:t,bX:n,d:l,e:r,f:c})}))}),Ta=a(function(e,n,r,o,t){return s(Ho,r,l(function(r,a,i,c,l,u,d,v){return m(Xo,f(ct,c,t,v),ha,Yo,o,{aP:s(At,nt(n),e),b:i,c:a,d:u,e:r,f:l})}))}),La={src:"\n        precision mediump float;\n        \n        uniform mediump vec3 emissiveColor;\n        uniform lowp float pointRadius;\n        uniform highp mat4 sceneProperties;\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        float pointAlpha(float pointRadius, vec2 pointCoord) {\n            float pointSize = 2.0 * pointRadius;\n            float x = (pointSize + 2.0) * (pointCoord.s - 0.5);\n            float y = (pointSize + 2.0) * (pointCoord.t - 0.5);\n            float r = sqrt(x * x + y * y);\n            float innerRadius = pointRadius;\n            float outerRadius = pointRadius + 1.0;\n            if (r > outerRadius) {\n                return 0.0;\n            } else if (r > innerRadius) {\n                return outerRadius - r;\n            } else {\n                return 1.0;\n            }\n        }\n        \n        void main () {\n            vec4 color = toSrgb(emissiveColor, sceneProperties);\n            float supersampling = sceneProperties[3][0];\n            float alpha = pointAlpha(pointRadius * supersampling, gl_PointCoord);\n            gl_FragColor = vec4(color.rgb, alpha);\n        }\n    ",attributes:{},uniforms:{emissiveColor:"aP",pointRadius:"bX",sceneProperties:"e"}},wa=a(function(e,n,r,o,t){return s(Pa,o,l(function(o,a,i,c,l,u,f,d){return m(Xo,d,ya,La,t,{aP:s(At,nt(n),e),b:i,c:a,bX:r,d:u,e:o,f:l})}))}),Na={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n        }\n    ",attributes:{normal:"q",position:"bY"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},za=t(function(e,n,r,o){return s(Ho,n,l(function(n,t,a,i,c,l,u,s){var d=u.a,v=u.b;return m(Xo,f(ct,i,o,s),Na,rt,r,{U:v,be:d.be,bN:d.bN,bO:d.bO,bP:d.bP,cp:e,b:a,c:t,d:l,e:n,f:c})}))}),Sa={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        attribute mediump vec2 uv;\n        attribute highp vec3 tangent;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        vec3 getWorldTangent(vec3 modelTangent, vec4 modelScale, mat4 modelMatrix) {\n            return (modelMatrix * vec4(safeNormalize(modelScale.xyz * modelTangent), 0.0)).xyz;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n            interpolatedUv = uv;\n            interpolatedTangent = getWorldTangent(tangent, modelScale, modelMatrix);\n        }\n    ",attributes:{normal:"q",position:"bY",tangent:"eg",uv:"N"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},Da=i(function(e,n,r,o,t,a){return s(Ho,o,l(function(o,i,c,l,u,s,d,v){var p=d.a,g=d.b;return m(Xo,f(ct,l,a,v),Sa,ot,t,{U:g,be:p.be,bN:p.bN,bO:p.bO,bP:p.bP,cq:e,b:c,c:i,aW:n,d:s,e:o,a$:r,f:u})}))}),_a=i(function(e,n,r,o,t,a){return s(Ho,o,l(function(o,i,c,l,u,s,d,v){var p=d.a,g=d.b;return m(Xo,f(ct,l,a,v),Na,lt,t,{ev:e,U:g,be:p.be,bN:p.bN,bO:p.bO,bP:p.bP,cs:r,b:c,c:i,d:s,fp:n,e:o,f:u})}))}),Va=a(function(e,n,r,o,t){return s(Ho,r,l(function(r,a,i,c,l,u,s,d){return m(Xo,f(ct,c,t,d),ga,Go,o,{b5:nt(n),bF:e,b:i,c:a,d:u,e:r,f:l})}))}),Aa={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        attribute mediump vec2 uv;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n            interpolatedUv = uv;\n            interpolatedTangent = vec3(0.0, 0.0, 0.0);\n        }\n    ",attributes:{normal:"q",position:"bY",uv:"N"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},qa=t(function(e,n,r,o){return s(Ho,n,l(function(n,t,a,i,c,l,u,s){var d=u.a,v=u.b;return m(Xo,f(ct,i,o,s),Aa,ot,r,{U:v,be:d.be,bN:d.bN,bO:d.bO,bP:d.bP,cq:e,b:a,c:t,aW:e,d:l,e:n,a$:0,f:c})}))}),Fa=u(function(e,n,r,o,t,a,i,c,u){return s(Ho,i,l(function(i,l,s,d,v,p,g,b){var h=g.a,x=g.b;return m(Xo,f(ct,d,u,b),Aa,ut,c,{b7:e,b9:n,ca:a,cb:o,U:x,be:h.be,bN:h.bN,bO:h.bO,bP:h.bP,ct:t,b:s,c:l,aW:e,d:p,cO:r,e:i,a$:0,f:v})}))}),Ba=r(function(e,n){switch(e.$){case 0:if(e.b.$){var r=e.b.a.E;switch(n.$){case 0:case 1:case 2:case 3:case 4:return jo;case 5:case 6:case 7:return F=n.c,B=n.d,d(ba,r,Ht(q=n.a),F,B);case 8:case 9:default:return jo}}else{var o=e.b.a;switch(n.$){case 0:return jo;case 1:case 2:case 3:case 4:case 5:case 6:case 7:return F=n.c,B=n.d,d(xa,o,Ht(q=n.a),F,B);case 8:case 9:return F=n.c,d(xa,o,Ht(q=n.a),F,0);default:return F=n.d,d(Ma,o,n.b,Ht(q=n.a),F)}}case 1:if(e.b.$)switch(r=e.b.a.E,a=e.c,n.$){case 0:case 1:case 2:case 3:case 4:return jo;case 5:case 6:case 7:return F=n.c,B=n.d,m(Va,r,a,Ht(q=n.a),F,B);case 8:case 9:default:return jo}else{var t=e.b.a,a=e.c;switch(n.$){case 0:return jo;case 1:case 2:case 3:case 4:case 5:case 6:case 7:return F=n.c,B=n.d,m(Ta,t,a,Ht(q=n.a),F,B);case 8:case 9:return F=n.c,m(Ta,t,a,Ht(q=n.a),F,0);default:return F=n.d,m(wa,t,a,n.b,Ht(q=n.a),F)}}case 2:var i=s(Lt,e.b,e.c);if(i.$){var c=i.a.a,u=i.b,p=u.a,g=u.b;switch(n.$){case 0:case 1:case 2:case 3:case 4:case 5:return jo;case 6:return F=n.c,x=n.d,d(qa,c,Ht(q=n.a),F,x);case 7:return F=n.c,x=n.d,v(Da,c,p,g,Ht(q=n.a),F,x);case 8:case 9:default:return jo}}else{var h=i.a;switch(n.$){case 0:case 1:return jo;case 2:F=n.c;var x=n.d;return d(za,h,Ht(q=n.a),F,x);case 3:return jo;case 4:F=n.c;x=n.d;return d(za,h,Ht(q=n.a),F,x);case 5:return jo;case 6:case 7:return F=n.c,x=n.d,d(za,h,Ht(q=n.a),F,x);case 8:case 9:default:return jo}}default:var P=d(Vt,e.b,e.c,e.d,e.e);if(P.$){var C=P.a,y=C.a,M=C.b,T=P.b,L=T.a,w=T.b,N=P.c,z=N.a,S=N.b,D=P.d;switch(p=D.a,g=D.b,n.$){case 0:case 1:case 2:case 3:case 4:case 5:return jo;case 6:return F=n.c,B=n.d,b(Fa,y,M,L,w,z,S,Ht(q=n.a),F,B);case 7:return q=n.a,F=n.c,B=n.d,function(e){return function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return function(u){return function(d){return function(v){return s(Ho,u,l(function(l,u,s,p,g,b,h,x){var P=h.a,C=h.b;return m(Xo,f(ct,p,v,x),Sa,ut,d,{b7:e,b9:n,ca:a,cb:o,U:C,be:P.be,bN:P.bN,bO:P.bO,bP:P.bP,ct:t,b:s,c:u,aW:i,d:b,cO:r,e:l,a$:c,f:g})}))}}}}}}}}}}}(y)(M)(L)(w)(z)(S)(p)(g)(Ht(q))(F)(B);case 8:case 9:default:return jo}}else{var _=P.a,V=P.b,A=P.c;switch(n.$){case 0:case 1:return jo;case 2:return F=n.c,B=n.d,v(_a,_,V,A,Ht(q=n.a),F,B);case 3:return jo;case 4:return F=n.c,B=n.d,v(_a,_,V,A,Ht(q=n.a),F,B);case 5:return jo;case 6:case 7:var q,F=n.c,B=n.d;return v(_a,_,V,A,Ht(q=n.a),F,B);case 8:case 9:default:return jo}}}}),Ra=r(function(e,n){return{$:5,a:e,b:n}}),$a=r(function(e,n){var r=e.a,o=e.b,t=e.c,a=n.eA;return{eA:{en:r*a.en,eo:o*a.eo,b4:t*a.b4},eX:r*n.eX,eY:o*n.eY,eZ:t*n.eZ}}),Ea=function(e){return function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return function(l){return function(u){var s,f,d={en:(f=o)[0],eo:f[1],b4:f[2],el:f[3]},m=(s={el:d.el,en:d.en*e.a,eo:d.eo*e.b,b4:d.b4*e.c},new Float64Array([s.en,s.eo,s.b4,s.el]));return g(n,r,m,t,a,i,c,l,u)}}}}}}}}}},ja=r(function(e,n){switch(n.$){case 0:return Eo;case 5:return s(Ra,n.a,s(ja,e,n.b));case 1:var r=n.b;return s(Ho,s($a,e,n.a),s(Ea,e,r));case 3:return n;case 2:return Yt(s(Ea,e,r=n.a));default:var o=n.a;return ko(s(Lr,ja(e),o))}}),ka=r(function(e,n){return s(ja,e,n)}),Ia=r(function(e,n){return n.b?f(Tr,qn,n,e):e}),Oa=function(e){return f(Tr,Ia,M,e)},Ha=q,Wa=function(e){return Ha(e)},Ua=t(function(e,n,r,o){return{$:2,a:e,b:n,c:r,d:o}}),Ya=t(function(e,n,r,o){return{$:3,a:e,b:n,c:r,d:o}}),Ga=t(function(e,n,r,o){return{$:4,a:e,b:n,c:r,d:o}}),Za=t(function(e,n,r,o){return{$:6,a:e,b:n,c:r,d:o}}),Ka=t(function(e,n,r,o){return{$:7,a:e,b:n,c:r,d:o}}),Xa=t(function(e,n,r,o){return{$:5,a:e,b:n,c:r,d:o}}),Qa=t(function(e,n,r,o){return{$:1,a:e,b:n,c:r,d:o}}),Ja=o(function(e,n,r){for(;;){var o=s(mr,32,e),t=o.a,a=o.b;if(0>P(fr(t),32))return s(gr,!0,{B:n,n:r,r:t});e=a,n=s(qn,ur(t),n),r+=1}}),ei=r(function(e,n){for(;;){if(!n.b)return!1;var r=n.b;if(e(n.a))return!0;e=e,n=r}}),ni=o(function(e,n,r){return e(n(r))}),ri=function(e){return!e},oi=r(function(e,n){return!s(ei,s(ni,ri,e),n)}),ti=r(function(e,n){return f(Tr,r(function(n,r){return e(n)?s(qn,n,r):r}),M,n)}),ai=r(function(e,n){var r=e.a,o=function(e){var n=e.a,o=e.b,t=e.c;return n>=0&&0>P(n,r)&&o>=0&&0>P(o,r)&&t>=0&&0>P(t,r)};return s(oi,o,n)?{F:n,an:e}:{F:s(ti,o,n),an:e}}),ii=r(function(e,n){return e*n}),ci=r(function(e,n){return n+e}),li=r(function(e,n){return e/n}),ui=F,si=function(e){return ui(e)},fi=a(function(e,n,r,o,t){for(;;){var a=o(n/r),i=s(qn,a,t);if(h(n,e))return i;e=e,n-=1,r=r,o=o,t=i}}),di=r(function(e,n){return 1>e?M:m(fi,0,e,e,n,M)}),mi={$:0},vi=function(e){return new Float64Array([e.en,e.eo,e.b4])},pi=function(e){return e},gi=r(function(e,n){var r,o,t=e.bY,a=e.N,i=a.a,c=a.b;return s(qn,{q:(o=e.q,vi(pi(o))),bY:(r=t,vi(Ot(r))),N:s(St,i,c)},n)}),bi=r(function(e,n){return 1>P(n,e)}),hi=r(function(e,n){return s(dr,e,n)}),xi=r(function(e,n){return s(Qo,e,n)}),Pi=c(function(e,n,r,o,t,a,i){for(;;){if(!i.b)return s(bi,(m={dK:n,dL:o,dM:a,dN:e,dO:r,dP:t}).dK,m.dN)&&s(bi,m.dL,m.dO)&&s(bi,m.dM,m.dP)?m:{dK:s(hi,m.dN,m.dK),dL:s(hi,m.dO,m.dL),dM:s(hi,m.dP,m.dM),dN:s(xi,m.dN,m.dK),dO:s(xi,m.dO,m.dL),dP:s(xi,m.dP,m.dM)};var c=i.a,l=i.b,u=Ct(c.bY),f=Pt(c.bY),d=xt(c.bY);e=s(Qo,e,d),n=s(dr,n,d),r=s(Qo,r,f),o=s(dr,o,f),t=s(Qo,t,u),a=s(dr,a,u),i=l}var m}),Ci=r(function(e,n){var r=Ct(e.bY),o=Pt(e.bY),t=xt(e.bY);return p(Pi,t,t,o,o,r,r,n)}),yi=function(e){return to(6.283185307179586*e)},Mi=r(function(e,n){var r=e,o=n,t=Ha(o);return{en:t*Ha(r),eo:t*ui(r),b4:ui(o)}}),Ti=($r=ua(1),Er=s(Jn,0,71),jr=s(di,72,s(Bt,0,yi(1))),kr=tr(36),Ir=s(Jn,0,kr-1),Or=s(di,kr,s(Bt,ao(90),ao(-90))),Hr=(Rr=Oa(s(Lr,function(e){return s(Lr,function(n){return{q:yo(s(Mi,e,n)),bY:f(Rt,s(ii,Wa(n)*Wa(e),$r),s(ii,Wa(n)*si(e),$r),s(ii,si(n),$r)),N:C(s(li,e,yi(1)),s(li,s(ci,ao(90),n),ao(180)))}},Or)},jr))).b?f(Ja,Rr,M,0):cr,Wr=r(function(e,n){return e*(kr+1)+n}),function(e){switch(e.$){case 0:return e;case 1:return d(Qa,e.a,e.b,e.c,1);case 2:return d(Ua,e.a,e.b,e.c,1);case 3:return d(Ya,e.a,e.b,e.c,1);case 4:return d(Ga,e.a,e.b,e.c,1);case 5:return d(Xa,e.a,e.b,e.c,1);case 6:return d(Za,e.a,e.b,e.c,1);case 7:return d(Ka,e.a,e.b,e.c,1);case 8:case 9:default:return e}}(function(e){var n=f($n,gi,M,e.an);if(n.b){var r=n.a,o=n.b,t=s(Zt,n,e.F);return d(Za,s(Ci,r,o),e,t,0)}return mi}(s(ai,Hr,Oa(s(Lr,function(e){return Oa(s(Lr,function(n){var r=s(Wr,e+1,n),o=s(Wr,e,n),t=s(Wr,e+1,n+1),a=s(Wr,e,n+1);return w([y(a,t,r),y(a,r,o)])},Ir))},Er)))))),Li=A,wi=r(function(e,n){for(;;){var r=s(Li,144,2*e+3),o=s(Li,144,2*e+2),t=2*e+1,a=2*e,i=s(qn,y(144,a,o),s(qn,y(a,r,o),s(qn,y(a,t,r),s(qn,y(t,145,r),n))));if(!e)return i;e-=1,n=i}}),Ni=o(function(e,n,r){return r>.5?n+(1-r)*(e-n):e+r*(n-e)}),zi=(Ur=s(r(function(e,n){for(;;){var r=f(Ni,0,6.283185307179586,e/72),o=s(qn,{bz:r,bT:0,b$:1},s(qn,{bz:r,bT:1,b$:1},n));if(!e)return o;e-=1,n=o}}),71,w([{bz:0,bT:0,b$:0},{bz:0,bT:1,b$:0}])),s(Zt,Ur,s(wi,71,M))),Si={src:"\n        precision highp float;\n        \n        attribute highp float angle;\n        attribute highp float offsetScale;\n        attribute highp float radiusScale;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 shadowLight;\n        \n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const lowp float kPerspectiveProjection = 0.0;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 getDirectionToLight(vec3 surfacePosition, vec4 xyz_type, vec4 rgb_parameter) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                return xyz_type.xyz;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                return normalize(lightPosition - surfacePosition);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec3 perpendicularTo(vec3 d) {\n            float absX = abs(d.x);\n            float absY = abs(d.y);\n            float absZ = abs(d.z);\n            if (absX <= absY) {\n                if (absX <= absZ) {\n                    float scale = 1.0 / length(d.zy);\n                    return vec3(0.0, -d.z * scale, d.y * scale);\n                } else {\n                    float scale = 1.0 / length(d.xy);\n                    return vec3(-d.y * scale, d.x * scale, 0.0);\n                }\n            } else {\n                if (absY <= absZ) {\n                    float scale = 1.0 / length(d.xz);\n                    return vec3(d.z * scale, 0.0, -d.x * scale);\n                } else {\n                    float scale = 1.0 / length(d.xy);\n                    return vec3(-d.y * scale, d.x * scale, 0.0);\n                }\n            }\n        }\n        \n        void main () {\n            vec4 worldCenter = getWorldPosition(vec3(0.0, 0.0, 0.0), modelScale, modelMatrix);\n            vec4 xyz_type = shadowLight[0];\n            vec4 rgb_parameter = shadowLight[1];\n            vec3 zDirection = getDirectionToLight(worldCenter.xyz, xyz_type, rgb_parameter);\n            vec3 xDirection = perpendicularTo(zDirection);\n            vec3 yDirection = cross(zDirection, xDirection);\n            float r = modelScale.x;\n            float adjustedRadius = r;\n            float zOffset = 0.0;\n            if (xyz_type.w == kPointLight) {\n                float distanceToLight = length(xyz_type.xyz - worldCenter.xyz);\n                float rSquared = r * r;\n                zOffset = rSquared / distanceToLight;\n                float zSquared = zOffset * zOffset;\n                adjustedRadius = sqrt(rSquared - zSquared) * radiusScale;\n            }\n            vec3 worldPosition =\n                worldCenter.xyz\n                    + zDirection * zOffset\n                    + xDirection * adjustedRadius * cos(angle)\n                    + yDirection * adjustedRadius * sin(angle);\n            vec3 directionToLight = getDirectionToLight(worldPosition, xyz_type, rgb_parameter);\n            float sceneDiameter = sceneProperties[3][1];\n            vec3 offset = -sceneDiameter * offsetScale * directionToLight;\n            vec4 offsetPosition = vec4(worldPosition + offset, 1.0);\n            gl_Position = projectionMatrix * (viewMatrix * offsetPosition);\n        }\n    ",attributes:{angle:"bz",offsetScale:"bT",radiusScale:"b$"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",shadowLight:"b2",viewMatrix:"f"}},Di=function(){return Yt(l(function(e,n,r,o,t,a,i,c){return m(Xo,s(ta,!0,c),Si,Qt,zi,{aE:f(Bo,0,0,1),b:r,c:n,d:a,e:e,b2:i,f:t})}))},_i=r(function(e,n){return{dj:h(e.dj,n.dj),s:e.s*n.s+e.t*n.v+e.u*n.y,t:e.s*n.t+e.t*n.w+e.u*n.z,u:e.s*n.u+e.t*n.x+e.u*n.A,v:e.v*n.s+e.w*n.v+e.x*n.y,w:e.v*n.t+e.w*n.w+e.x*n.z,x:e.v*n.u+e.w*n.x+e.x*n.A,y:e.y*n.s+e.z*n.v+e.A*n.y,z:e.y*n.t+e.z*n.w+e.A*n.z,A:e.y*n.u+e.z*n.x+e.A*n.A,J:n.J+(e.J*n.s+e.K*n.v+e.L*n.y)*n.b1,K:n.K+(e.J*n.t+e.K*n.w+e.L*n.z)*n.b1,L:n.L+(e.J*n.u+e.K*n.x+e.L*n.A)*n.b1,b1:e.b1*n.b1}}),Vi=r(function(e,n){var r=n;switch(r.$){case 0:return jo;case 5:var o=r.b;return s(Ra,s(_i,r.a,e),o);case 1:case 3:case 2:default:return s(Ra,e,r)}}),Ai=r(function(e,n){return s(Vi,function(e){var n=pi(e);return{dj:!0,s:1,t:0,u:0,v:0,w:1,x:0,y:0,z:0,A:1,J:n.en,K:n.eo,L:n.b4,b1:1}}(e),n)}),qi=t(function(e,n,r,o){var t,a=s(Ba,r,Ti),i=(t=C(e,n)).a?t.b?Oo(w([a,Di()])):a:t.b?Di():jo,c=o.fm;return s(Ai,s(so,wo,o.eA),s(ka,y(c,c,c),i))}),Fi=r(function(e,n){return d(qi,!0,!0,e,n)}),Bi=r(function(e,n){return{eA:n,fm:No(e)}}),Ri=s(Fi,function(e){var n=e.fp,r=e.cs;return m(da,0,Ao(function(e){var n=Fo(e),r=n.cd,o=n.b8;return f(Bo,pa(n.cK),pa(r),pa(o))}(e.ev)),Ao(f(ma,0,1,n)),Ao(f(ma,0,1,r)),Ao(0))}({ev:(Yr={ev:fa,fp:.1}).ev,cs:0,fp:Yr.fp}),s(Bi,ua(1),f(Lo,0,0,1))),$i=function(e){return{$:0,a:e}},Ei={$:3},ji=t(function(e,n,r,o){return{$:4,a:e,b:n,c:r,d:o}}),ki=r(function(e,n){return Oa(s(Lr,e,n))}),Ii=function(e){return s(Ne,"height",Yn(e))},Oi=function(e){return Le(function(e){return"script"==e?"p":e}(e))},Hi=E,Wi=function(e){return{$:2,a:e}},Ui=we,Yi=O,Gi=o(function(e,n,r){return f(Ln,e,n,r)}),Zi=function(e){return e},Ki=d(yt,1,1,1,1),Xi=o(function(e,n,r){return s(Lr,function(e){return s(e,n,r)},e)}),Qi=o(function(e,n,r){return{$:0,a:e,b:n,c:r}}),Ji=r(function(e,n){var r=n.en,o=n.eo;return f(Qi,e*r/o,e,e*(1-r-o)/o)}),ec=r(function(e,n){return f(Bo,3.2406*(o=(r=s(Ji,e,n)).a)-1.5372*(t=r.b)-.4986*(a=r.c),-.9689*o+1.8758*t+.0415*a,.0557*o-.204*t+1.057*a);var r,o,t,a}),nc=a(function(e,n,r,o,t){return v(t,e,d(yt,o.b1,o.b1,o.b1,o.dj?1:-1),function(e){return ft({dt:e.s,du:e.v,dv:e.y,dw:e.J,dx:e.t,dy:e.w,dz:e.z,dA:e.K,dB:e.u,dC:e.x,dD:e.A,dE:e.L,dF:0,dG:0,dH:0,dI:1})}(o),o.dj,n,r)}),rc=i(function(e,n,r,o,t,a){e:for(;;)switch(t.$){case 0:return a;case 5:var i=t.b;e=e,n=n,r=r,o=s(_i,t.a,o),t=i,a=a;continue e;case 1:return{P:s(qn,m(nc,e,n,r,o,t.b),a.P),_:a._,fq:a.fq};case 3:return{P:a.P,_:s(qn,m(nc,e,n,r,o,t.b),a._),fq:a.fq};case 2:return{P:a.P,_:a._,fq:s(qn,m(nc,e,n,r,o,t.a),a.fq)};default:var c=t.a;return f(Zn,d(rc,e,n,r,o),a,c)}}),oc=t(function(e,n,r,o){return{$:4,a:e,b:n,c:r,d:o}}),tc=t(function(e,n,r,o){return{$:1,a:e,b:n,c:r,d:o}}),ac=r(function(e,n){return{$:6,a:e,b:n}}),ic=w([d(tc,518,!1,0,1),d(oc,!1,!1,!1,!1),s(ac,0,1)]),cc={src:"\n        precision lowp float;\n\n        void main() {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n    ",attributes:{},uniforms:{}},lc=vt({c8:1,di:0,dR:5})(w([{bY:s(St,-1,-1)},{bY:s(St,1,-1)},{bY:s(St,-1,1)},{bY:s(St,1,1)}])),uc={src:"\n        precision lowp float;\n\n        attribute vec2 position;\n\n        void main() {\n            gl_Position = vec4(position, 0.0, 1.0);\n        }\n    ",attributes:{position:"bY"},uniforms:{}},sc=function(e){return f(na,{co:e.co,cL:e.cL,cY:e.cY},{a9:e.a9,bo:e.bo,bw:e.bw,bx:e.bx},{a9:e.a9,bo:e.bo,bw:e.bw,bx:e.bx})},fc=function(e){return m(Xo,w([sc(e),d(oc,!1,!1,!1,!1)]),uc,cc,lc,{})},dc=fc({a9:7681,co:0,cL:8,bo:519,cY:15,bw:7681,bx:7681}),mc=function(e){return fc({a9:7680,co:15,cL:8,bo:516,cY:(n=e,s(va,2,n+4)),bw:5386,bx:5386});var n},vc=o(function(e,n,r){return Oa(w([f(Xi,e,r,ic),w([mc(n),dc])]))}),pc=r(function(e,n){return Oa(s(er,vc(e),n))}),gc=d(tc,513,!0,0,1),bc=o(function(e,n,r){return{$:0,a:e,b:n,c:r}}),hc=r(function(e,n){return f(bc,32774,e,n)}),xc=function(e){var n=e.b_,o=e.bI,t=e.bB,a=e.by,i=e.bE,c=e.aM;return s(r(function(e,r){var i=e.b,c=e.c,l=r.a,u=r.b,s=r.c;return function(e){return function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return function(l){return function(u){return{$:0,a:e,b:n,c:r,d:o,e:t,f:a,g:i,h:c,i:l,j:u}}}}}}}}}}}(e.a)(i)(c)(l)(u)(s)(n)(o)(t)(a)}),i,c)}({by:0,aM:s(hc,1,771),bB:0,bE:s(hc,770,771),bI:0,b_:0}),Pc=w([gc,xc]),Cc=function(e){return e.cy},yc=function(e){return Cc(e)},Mc=function(e){return Mo({cy:(n={en:e.J,eo:e.K,b4:e.L},n),cZ:Do({en:e.s,eo:e.t,b4:e.u}),c_:Do({en:e.v,eo:e.w,b4:e.x}),c$:Do({en:e.y,eo:e.z,b4:e.A})});var n},Tc=r(function(e,n){var r=e.c$,o=e.c_,t=e.cZ;return{en:n.en*t.en+n.eo*t.eo+n.b4*t.b4,eo:n.en*o.en+n.eo*o.eo+n.b4*o.b4,b4:n.en*r.en+n.eo*r.eo+n.b4*r.b4}}),Lc=r(function(e,n){var r=e.cy,o=n.en-r.en,t=n.eo-r.eo,a=n.b4-r.b4,i=e.c$,c=e.c_,l=e.cZ;return{en:o*l.en+t*l.eo+a*l.b4,eo:o*c.en+t*c.eo+a*c.b4,b4:o*i.en+t*i.eo+a*i.b4}}),wc=function(e){return e.cZ},Nc=function(e){return e.c_},zc=function(e){return e.c$},Sc=r(function(e,n){return{cy:s(Lc,e,Cc(n)),cZ:s(Tc,e,wc(n)),c_:s(Tc,e,Nc(n)),c$:s(Tc,e,zc(n))}}),Dc=function(e){return e},_c=r(function(e,n){var r=Dc(n),o=Dc(e);return{dK:s(hi,o.dK,r.dK),dL:s(hi,o.dL,r.dL),dM:s(hi,o.dM,r.dM),dN:s(xi,o.dN,r.dN),dO:s(xi,o.dO,r.dO),dP:s(xi,o.dP,r.dP)}}),Vc=function(e){return e},Ac=r(function(e,n){var r=e.a,o=e.c,t=zo(No(e.b)),a=zo(No(r)),i=zo(No(o)),c=y(n.en,n.eo,n.b4),l=c.a,u=c.b,f=c.c;return{dK:s(ci,a,l),dL:s(ci,t,u),dM:s(ci,i,f),dN:s(kt,a,l),dO:s(kt,t,u),dP:s(kt,i,f)}}),qc=t(function(e,n,r,o){var t=r.eA,a=2*r.eZ*n,i=2*r.eY*n,c=2*r.eX*n,l=t.b4*n,u=t.eo*n,d=t.en*n,m=Vc(zc(e)),v=co(c*m.en)+co(i*m.eo)+co(a*m.b4),p=Vc(Nc(e)),g=co(c*p.en)+co(i*p.eo)+co(a*p.b4),b=Vc(wc(e)),h=co(c*b.en)+co(i*b.eo)+co(a*b.b4),x=s(Ac,y(h,g,v),s(Lc,e,f(Lo,d,u,l)));return Wn(o.$?x:s(_c,o.a,x))}),Fc=t(function(e,n,r,o){e:for(;;){if(!o.b)return r;var t=o.a,a=o.b;switch(t.$){case 0:e=c=e,n=l=n,r=u=r,o=a;continue e;case 1:var i=d(qc,e,n,t.a,r);e=c=e,n=l=n,r=u=i,o=a;continue e;case 2:e=c=e,n=l=n,r=u=r,o=a;continue e;case 3:i=d(qc,e,n,t.a,r),e=c=e,n=l=n,r=u=i,o=a;continue e;case 4:var c=e,l=n,u=d(Fc,e,n,r,t.a);e=c,n=l,r=u,o=a;continue e;default:var f=t.a,m=t.b,v=s(Sc,Mc(f),e),p=n*f.b1;e=c=e,n=l=n,r=u=d(Fc,v,p,r,w([m])),o=a;continue e}}}),Bc={dj:!0,s:1,t:0,u:0,v:0,w:1,x:0,y:0,z:0,A:1,J:0,K:0,L:0,b1:1},Rc=function(e){return e},$c=fc({a9:7681,co:0,cL:8,bo:519,cY:255,bw:7681,bx:7681}),Ec={bB:0,ez:!1,bI:0,cH:0,b_:0,cV:0,en:0,eo:0,b4:0},jc=r(function(e,n){return ft({dt:e.en,du:e.b_,dv:n.en,dw:n.b_,dx:e.eo,dy:e.bI,dz:n.eo,dA:n.bI,dB:e.b4,dC:e.bB,dD:n.b4,dE:n.bB,dF:e.cV,dG:e.cH,dH:n.cV,dI:n.cH})}),kc=C({be:s(jc,Ec,Ec),bN:s(jc,Ec,Ec),bO:s(jc,Ec,Ec),bP:s(jc,Ec,Ec)},d(yt,0,0,0,0)),Ic=function(e){return-e},Oc=function(e){return d(tc,515,e.ae,e.ab,e.aa)},Hc=w([Oc({aa:1,ab:0,ae:!0}),sc({a9:7680,co:240,cL:0,bo:514,cY:0,bw:7680,bx:7680}),xc]),Wc=function(e){return e===1/0||e===-1/0},Uc=r(function(e,n){var r=e,o=n.eV,t=n.es,a=No(n.e9),i=No(o),c=r.cJ;if(c.$){var l=c.a;return Wc(i)?ft({dt:2/(t*l),du:0,dv:0,dw:0,dx:0,dy:2/l,dz:0,dA:0,dB:0,dC:0,dD:0,dE:-1,dF:0,dG:0,dH:0,dI:1}):ft({dt:2/(t*l),du:0,dv:0,dw:0,dx:0,dy:2/l,dz:0,dA:0,dB:0,dC:0,dD:-2/(i-a),dE:-(i+a)/(i-a),dF:0,dG:0,dH:0,dI:1})}var u=c.a;return Wc(i)?ft({dt:1/(t*u),du:0,dv:0,dw:0,dx:0,dy:1/u,dz:0,dA:0,dB:0,dC:0,dD:-1,dE:-2*a,dF:0,dG:0,dH:-1,dI:0}):ft({dt:1/(t*u),du:0,dv:0,dw:0,dx:0,dy:1/u,dz:0,dA:0,dB:0,dC:0,dD:-(i+a)/(i-a),dE:-2*i*a/(i-a),dF:0,dG:0,dH:-1,dI:0})}),Yc=r(function(e,n){return 1==(1&e>>n)?0:1}),Gc=o(function(e,n,r){return Oa(s(Lr,function(r){var o=r<<4;return f(Xi,e,C(n,d(yt,s(Yc,r,0),s(Yc,r,1),s(Yc,r,2),s(Yc,r,3))),function(e){return w([Oc({aa:1,ab:0,ae:!0}),sc({a9:7680,co:240,cL:e,bo:514,cY:0,bw:7680,bx:7680}),xc])}(o))},s(Jn,1,s(va,2,r)-1)))}),Zc=function(e){return{en:-e.en,eo:-e.eo,b4:-e.b4}},Kc=function(e){return Zc(zc(e))},Xc=Do({en:1,eo:0,b4:0}),Qc=Do({en:0,eo:1,b4:0}),Jc=_o,el={cy:wo,cZ:Xc,c_:Qc,c$:Jc},nl=r(function(e,n){var r,o,t,a,i;return o=Ot(Cc(r=s(Sc,n,e))),t=Vc(zc(r)),a=Vc(Nc(r)),i=Vc(wc(r)),ft({dt:i.en,du:a.en,dv:t.en,dw:o.en,dx:i.eo,dy:a.eo,dz:t.eo,dA:o.eo,dB:i.b4,dC:a.b4,dD:t.b4,dE:o.b4,dF:0,dG:0,dH:0,dI:1})}),rl=o(function(e,n,r){return{en:e,eo:n,b4:r}}),ol=function(e){return Nc(e)},tl=r(function(e,n){var r,o,t=w([(o=1,{$:1,a:o}),Wi(0),$i(!0),d(ji,0,0,0,0)]),a=function(){var n=e.aN;switch(n.$){case 0:return y(t,"0",1);case 1:return y(s(qn,Ei,t),"1",1);default:return y(t,"0",n.a)}}(),i=a.a,c=a.b,l=a.c,u=e.eH,m=u.a,p=Zi(u.b),g=s(Ui,"height",Yn(p)+"px"),b=Zi(m),h=b/p,x=s(ki,function(n){return function(e){var n=e.ey.fD,r=Mo({cy:yc(n),cZ:(a=n,wc(a)),c_:ol(n),c$:Zc(Kc(n))}),o=Oo(e.eN),t=d(Fc,r,1,Un,w([o]));var a;if(1===t.$)return M;var i,c=t.a,l=s(nl,el,n),u=s(ii,.99,s(hi,No(e.eD),Ic(Et(c)))),m=It(c),p=function(){var e=f(rl,m.a,m.b,m.c),n=s(dr,co(e.en),s(dr,co(e.eo),co(e.b4)));if(n){var r=e.b4/n,o=e.eo/n,t=e.en/n;return lo(t*t+o*o+r*r)*n}return 0}(),g=s(ii,1.01,s(ci,p,Ic(jt(c)))),b=s(Uc,e.ey,{es:e.es,eV:g,e9:u}),h=(i=b,{dt:i[0],dx:i[1],dB:i[2],dF:i[3],du:i[4],dy:i[5],dC:i[6],dG:i[7],dv:i[8],dz:i[9],dD:i[10],dH:i[11],dw:i[12],dA:i[13],dE:i[14],dI:i[15]}).dI,x=h?Vc(Zc(Kc(n))):dt(yc(n)),P=function(){var n=e.ax;switch(n.$){case 0:return C(0,0);case 1:return C(1,0);case 2:return C(2,0);case 3:return C(3,n.a);case 4:return C(4,n.a);default:return C(5,0)}}(),y=P.a,T=P.b,L=s(ec,e.aq,e.aA),N=ft({dt:0,du:x.en,dv:xt(L),dw:e.ee,dx:0,dy:x.eo,dz:Pt(L),dA:Rc(p),dB:0,dC:x.b4,dD:Ct(L),dE:y,dF:0,dG:h,dH:0,dI:T}),z=v(rc,N,l,b,Bc,o,{P:M,_:M,fq:M}),S=e.as;switch(S.$){case 0:return Oa(w([f(Xi,z.P,C(D=S.a,Ki),Pc),f(Xi,z._,kc,Pc)]));case 1:var D=S.a;return Oa(w([f(Xi,z.P,kc,Pc),w([$c]),f(Xi,z.fq,D.be,ic),w([mc(0)]),f(Xi,z.P,C(D,Ki),Hc),f(Xi,z._,kc,Pc)]));default:var _=S.a,V=S.b;return Oa(w([f(Xi,z.P,C(V,Ki),Pc),w([$c]),s(pc,z.fq,_),f(Gc,z.P,V,Kn(_)),f(Xi,z._,kc,Pc)]))}}({es:h,ey:e.ey,eD:e.eD,eN:n.eN,aq:n.aq,as:n.as,ee:l,ax:n.ax,aA:n.aA})},n),P=s(Ui,"width",Yn(b)+"px"),T=function(e){var n,r,o=e.b,t=e.c,a=e.d,i=function(e){return Hi(1e4*e)/100};return n=w(["rgba(",Yi(i(e.a)),"%,",Yi(i(o)),"%,",Yi(i(t)),"%,",Yi((r=a,Hi(1e3*r)/1e3)),")"]),s(Gn,"",n)}(e.eu);return f(Oi,"div",w([s(Ui,"padding","0px"),P,g]),w([C(c,f(Gi,i,w([(r=Hi(b*l),s(Ne,"width",Yn(r))),Ii(Hi(p*l)),P,g,s(Ui,"display","block"),s(Ui,"background-color",T)]),x))]))}),al=function(e){return e},il=al({en:.31271,eo:.32902}),cl=r(function(e,n){var r=e,o=Vc(n.eI),t=o.en,a=o.eo,i=o.b4,c=s(ec,n.cf,n.bD);return{bB:Ct(c),ez:r,bI:Pt(c),cH:0,b_:xt(c),cV:1,en:-t,eo:-a,b4:-i}}),ll=function(e){return e},ul={$:1},sl={$:0},fl=function(e){return e},dl=function(e){return function(e){for(;;){if(h(e.e2,0)&&h(e.e3,0))return Ec;if(!s(vo,No(e.e2),No(e.e3))){var n=co(fl(e.e3)/3.141592653589793),r=co(fl(e.e2)/3.141592653589793),o=Vc(e.ej),t=o.en,a=o.eo,i=o.b4,c=s(ec,1,e.bD);return{bB:r*Ct(c),ez:!1,bI:r*Pt(c),cH:n/r,b_:r*xt(c),cV:3,en:t,eo:a,b4:i}}e={bD:e.bD,e2:e.e3,e3:e.e2,ej:Zc(e.ej)}}}({bD:e.bD,e2:e.cf,e3:0,ej:e.ej})},ml=function(e){var n=f(ma,1667,25e3,e),r=n>4e3?-3025846900/(n*n*n)+2107037.9/(n*n)+.2226347*1e3/n+.24039:1e9*-.2661239/(n*n*n)-.2343589*1e6/(n*n)+877.6956/n+.17991;return al({en:r,eo:n>2222?n>4e3?r*r*r*3.081758-r*r*5.8733867+3.75112997*r-.37001483:r*r*r*-.9549476-r*r*1.37418593+2.09137015*r-.16748867:r*r*r*-1.1063814-r*r*1.3481102+2.18555832*r-.20219683})},vl=function(e){return e},pl=ml(vl(12e3)),gl=ml(vl(5600)),bl=r(function(e,n){return{$:2,a:e,b:n}}),hl=function(e){return{$:0,a:e}},xl=function(e){return e},Pl=function(e){return e.ez},Cl=hl(kc.a),yl=r(function(e,n){return f(Tr,r(function(n,r){var o=r.a,t=r.b;return e(n)?C(s(qn,n,o),t):C(o,s(qn,n,t))}),C(M,M),n)}),Ml=function(e){return ft({dt:e.en,du:e.b_,dv:0,dw:0,dx:e.eo,dy:e.bI,dz:0,dA:0,dB:e.b4,dC:e.bB,dD:0,dE:0,dF:e.cV,dG:e.cH,dH:0,dI:0})},Tl=l(function(e,n,r,o,t,a,i,c){var l=s(yl,Pl,w([xl(e),xl(n),xl(r),xl(o)])),u=l.a;if(u.b){var f=function(e,n){if("string"==typeof e)return e+n;if(!e.b)return n;var r=T(e.a,n);e=e.b;for(var o=r;e.b;e=e.b)o=o.b=T(e.a,n);return r}(u,l.b);if(f.b&&f.b.b&&f.b.b.b&&f.b.b.b.b&&!f.b.b.b.b.b){var d=f.a,m=f.b,v=m.a,p=m.b,g=p.a,b=p.b.a;return s(bl,s(Lr,Ml,u),{be:s(jc,d,v),bN:s(jc,g,b),bO:s(jc,t,a),bP:s(jc,i,c)})}return Cl}return hl({be:s(jc,e,n),bN:s(jc,r,o),bO:s(jc,t,a),bP:s(jc,i,c)})}),Ll=o(function(e,n,r){return g(Tl,e,n,r,Ec,Ec,Ec,Ec,Ec)}),wl=function(e){var n=s(cl,e.fq,{bD:gl,eI:e.fv,cf:ll(8e4)}),r=dl({bD:pl,cf:ll(2e4),ej:e.ej}),o=dl({bD:il,cf:ll(15e3),ej:Zc(e.ej)}),t=f(Ll,n,r,o);return function(e){return s(tl,{aN:e.aN,eu:e.eu,ey:e.ey,eD:e.eD,eH:e.eH},w([{eN:e.eN,aq:e.aq,as:e.as,ax:e.ax,aA:e.aA}]))}({aN:ul,eu:e.eu,ey:e.ey,eD:e.eD,eH:e.eH,eN:e.eN,aq:(15,1.2*s(va,2,15)),as:t,ax:sl,aA:il})}({eu:d(t(function(e,n,r,o){return d(Ro,e,n,r,o)}),0,0,0,0),ey:Vo,eD:ua(1),eH:C(la(600),la(600)),eN:w([Ri,ca]),fq:!0,fv:sa,ej:Jc});Gr={Main:{init:Kr({e1:function(){return Jr},fu:function(){return no},fz:ro,fC:function(){return s(oo,M,w([wl]))}})((Zr=0,{$:0,a:Zr}))(0)}},e.Elm?function e(n,r){for(var o in r)o in n?"init"==o?_(6):e(n[o],r[o]):n[o]=r[o]}(e.Elm,Gr):e.Elm=Gr}(this);
},{}],"IrIc":[function(require,module,exports) {

},{}],"QvaY":[function(require,module,exports) {
"use strict";var e=require("../Main.elm");require("../style/main.scss"),e.Elm.Main.init({node:document.getElementById("main")});
},{"../Main.elm":"asWa","../style/main.scss":"IrIc"}]},{},["QvaY"], null)
//# sourceMappingURL=js.53c82857.js.map